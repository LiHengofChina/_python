
示例：

	@lru_cache(maxsize=None)
	def fib_memo(n: int) -> int:



示例：

	from functools import lru_cache

	@lru_cache(maxsize=None)
	def add(a, b):
		print("正在计算...")
		return a + b

	print(add(2, 3))  # 第一次会计算
	print(add(2, 3))  # 第二次直接用缓存，不会再打印


//======================================================= @lru_cache 是什么
//======================================================= @lru_cache 是什么

（1）@lru_cache 是 Python 标准库 functools 里的一个装饰器。
（2）全称：Least Recently Used cache（最近最少使用缓存）。
（3）用它装饰函数后，函数的输入参数和返回结果会自动存到缓存里。
（4）下次调用这个函数，如果参数相同，就会直接返回缓存结果，不再重新计算。

//======================================================= maxsize=None
//======================================================= maxsize=None
maxsize 表示缓存能存多少条记录。

默认比如 maxsize=128，超过 128 条旧的就会被丢掉（LRU 策略）。

写 maxsize=None 表示缓存无限大，不会丢弃任何结果。

对 Fibonacci 这种递归题，None 最合适，因为最多只会缓存 n+1 个值。

//======================================================= 总结
//======================================================= 总结

@lru_cache(maxsize=None) 就是一个 函数结果记忆工具，帮你自动保存已经算过的结果，下次相同输入直接取缓存，省去重复计算。


//======================================================= java中有类似的工具吗
//======================================================= java中有类似的工具吗

Java 里没有内置 @lru_cache 这样的装饰器，因为 Java 偏向业务开发，语言层面更关注类型系统和企业框架。要做缓存，通常会用：

手写 HashMap<Integer, Integer> 来存递归结果；

或者用第三方库（Guava Cache、Caffeine）做更复杂的缓存。

//======================================================= 手写字典存储 vs @lru_cache
//======================================================= 手写字典存储 vs @lru_cache

没有本质区别，都是 把参数和结果存起来，下次直接取；

@lru_cache 只是 Python 语法糖，帮你省掉写 dict 的代码，还能控制缓存大小和淘汰策略。


