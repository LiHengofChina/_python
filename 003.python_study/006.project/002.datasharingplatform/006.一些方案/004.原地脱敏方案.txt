


//====================================================== 原地脱敏方案
//====================================================== 原地脱敏方案



（1）首先我会标识出一张表中的所有"需要脱敏"的字段
	（1）和更新分离的
	（2）这部分标记的记录，最好也存在数据库端

（2）然后计算出脱敏后数据，在数据库内算
	 //避免数据来回传 // "在原地处理"：
	（1）UPDATE user SET phone = CONCAT(SUBSTR(phone,1,3), '***', SUBSTR(phone, -2)) WHERE phone IS NOT NULL; 
	（2）UPDATE user SET phone = REGEXP_REPLACE(phone, '(\\d{3})\\d+(\\d{2})', '\\1***\\2'); 

（3）分批更新字段
	 //是否分批 + 有索引 控制事务大小 降低行锁时间 避免主从延迟爆炸 避免 undo / redo 撑爆
	（1）UPDATE user SET phone = ... WHERE id > ? AND id <= ? LIMIT 1000;
	（2）UPDATE user SET phone = ... WHERE id BETWEEN ? AND ?



//====================================================== 公司现有方案
//====================================================== 公司现有方案

实现是 "偏重流程与合规"，但在
大数据量 + 数据库原地脱敏 + 性能/可控性 方面问题比较明显。


核心问题（重点）
	（1）不是原地脱敏（❌）
	（2）扫描 ≠ 脱敏强耦合（设计偏重）
	（3）脱敏规则只能在 Java 里实现（性能 & 扩展性问题）

... 等等，简单说它的数据传来传去，会导致

//===================== 总结：
//===================== 总结：
它把数据在 "数据库 ↔ 应用 ↔ 文件" 之间来回传输，产生大量 IO 和网络开销，
导致在大数据量场景下效率明显偏低。


