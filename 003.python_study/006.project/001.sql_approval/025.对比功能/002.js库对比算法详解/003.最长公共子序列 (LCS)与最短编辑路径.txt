
//=================================================== 概念
//=================================================== 概念

求"最长公共子序列" 和 "最短编辑路径" 它们是两个概念

	（1）最长公共子序列 (LCS)：找两个序列里 "共同的最长部分" 。
	（2）最短编辑路径 (Edit Distance)：找把 A 变成 B 所需的 "最少操作数"。

//=================================================== 关系：
//=================================================== 关系：

最短编辑路径 = A 长度 + B 长度 − 2 × LCS 长度。

所以两者是不同角度，但数学上是关联的。

//===================================================
//===================================================

最短编辑路径 的计算本质上依赖于 最长公共子序列 (LCS)：

公共部分（LCS）不需要改动。
非公共部分才需要插入或删除。

公式就是：
	最短编辑路径长度 = |A| + |B| − 2 × |LCS|。

//=================================================== 我的应用
//=================================================== 我的应用
我求两个文本相似度，

	（1）传入完整文本也是合理的
			//完全合理 👍。直接用全文跑 LCS / 最短编辑路径，就能衡量整体相似度。

	（2）在传入之前排序等处理也是合理的
			//如果比较的是“内容集合”（顺序不重要），排序后再比更合理。
			//如果比较的是“顺序敏感”的文本（代码、语句），就不要打乱顺序。

//=================================================== 为什么我的结果就有些是一行的内容被拆分了
//=================================================== 为什么我的结果就有些是一行的内容被拆分了

	由于是 "最短编辑路径" 如 ABC → AC → ACD，所以有很多步骤，
	所以中途所以我完整的行或有些一起的内容，
	被这个算法 给拆分了，实际拆分的就是它的步数
	//============
	//============
	看到 ABC → AC → ACD 这种，就是 最短编辑路径的一条 "逐步操作序列"。
	每一步（删 B、加 D）就是一次 编辑操作。
	这些操作连起来，就构成了 "算法的路径" 。
	所以某些连续的内容被 "拆开"， 正是因为算法要把它们一步步转换，中间的每个动作都算一步。
	"被拆分，其实就是 算法在记录最短路径的每个操作步骤。"
	//============
	//============
	最后我通过我的代码，处理还原它拆分的内容，也是合理的
	在代码里把拆分的片段再合并还原，完全合理。

//=================================================== 我的代码分析：代码片段1
//=================================================== 我的代码分析：代码片段1


Value diffLines = context.eval("js",
		"(a, b) => Diff.diffWordsWithSpace(a, b, { delimiters: /[ \\t\\r\\n]+/ })"
);

这段代码调用的是 diffWordsWithSpace，
它内部还是基于 "Myers O(ND) 算法" 来算 "最短编辑路径"，
只是结果被封装成了 "差异块数组"（哪些部分相同、哪些新增、哪些删除）。

所以拿到的 result，本质上就是 "最短编辑路径的结构化结果"。


//=================== 分隔符的作用
//=================== 分隔符的作用

"(a, b) => Diff.diffWordsWithSpace(a, b, { delimiters: /[ \\t\\r\\n]+/ })" 
这里指定了分隔符号，它在 Myers O(ND) 算法 中起什么作用呢

先把文本按分隔符切成“最小单元”，然后再用 Myers O(ND) 算法 去比对这些单元。
//分隔符决定了“比较的粒度”（按单词、按行、还是按字符）。

//=================== 在比较之前先切分成小单元
//=================== 在比较之前先切分成小单元

//举个例子：
	（1）如果不切分 → 算法直接按字符比较： "hello world"
	（2）如果指定空格作为分隔符 → 算法就把它切成单元：
			["hello", "world"]，再把这两个数组丢给 Myers 算法。
//谁和谁比较？
	小单元序列和小单元序列比较。
	这样就简化了，因为算法不用处理"所有字符"，而是处理"单元序列"，
	结果更符合"人类理解的差异"（比如按词或按行对比）。
//=================================================== 我的代码分析：代码片段2
//=================================================== 我的代码分析：代码片段2
	 for (int i = 0; i < result.getArraySize(); i++) {
		 
			Value part = result.getArrayElement(i);
			String value = part.getMember("value").asString();
			boolean added = part.hasMember("added") && part.getMember("added").asBoolean();
			boolean removed = part.hasMember("removed") && part.getMember("removed").asBoolean();

			String[] lines = value.split("\n", -1);
			for (int j = 0; j < lines.length; j++) {
					if (j > 0) {
						sourceLines.add("");
						targetLines.add("");
					}
					int currentLineIndex = sourceLines.size() - 1;

					if (added) {
						targetLines.set(currentLineIndex, targetLines.get(currentLineIndex) + lines[j]);
					} else if (removed) {
						sourceLines.set(currentLineIndex, sourceLines.get(currentLineIndex) + lines[j]);
					} else {
						sourceLines.set(currentLineIndex, sourceLines.get(currentLineIndex) + lines[j]);
						targetLines.set(currentLineIndex, targetLines.get(currentLineIndex) + lines[j]);
					}
			}
	}
	/**
	（1）这段代码就是在循环遍历  "差异块" 的每一步结果（added / removed / 相同）
	
	（2）for (int i = 0; i < result.getArraySize(); i++) { 这里循环的是 "差异块" 的数量
	
	（3）for (int j = 0; j < lines.length; j++) { //diff 库返回的 value 本质上是一个 差异块（chunk），	
												  //每个差异块里具体的内容（逐行拆分后的说明）
														

	
	（3）注意******************
				最短编辑路径 只告诉你 "最少要多少步" 把 A 变成 B，
				但 "差异块数量" 是库在封装结果时，为了展示可读性而分组出来的，二者没有一一对应关系。


	（3）以 ABC 与 ACD 比较为例
		 最短编辑路径： ABC → AC → ACD 

		 //=================== 差异块数量
		 以  const result = diffWords('ABC', 'ACD'); console.log(result); 为例子
		（1）{ value: 'A' } → 同时写入 sourceLines 和 targetLines。
		（2）{ value: 'B', removed: true } → 只写入 sourceLines。
		（3）{ value: 'C' } → 同时写入 sourceLines 和 targetLines。
		（4）{ value: 'D', added: true } → 只写入 targetLines。
		 //=================== 结果
			A  A
			B  
			C  C
			   D

	*/
//===================================================  value.split("\n", -1); 这里为什么要 \n
//===================================================  value.split("\n", -1); 这里为什么要 \n

 注意 ****************************** 这里为什么要 \n
			String[] lines = value.split("\n", -1);
		（1）我原来的数据里面就有\n ，是分割符号
		（2）diff 库的差异块 不会按行切开，只是原封不动把换行符包含在 value 里。
		    如果你要逐行对齐展示（让 source/target 一行对应一行），那就必须自己用 split("\n") 来切分。
		（3）在 diff 库的计算里 \n 只是普通字符，也会算进编辑距离；

		（4）我原来按 \n 分行，它并不会特别识别行，只当成普通内容。
			 Value result = diffLines.execute(sourceContent == null ? "" : sourceContent, targetContent == null ? "" : targetContent);
			 因为它的两个参数是字符串
			 diffLines.execute(...) 接收的就是两个完整的 字符串 参数，里面的 \n 只是普通字符，不会被特殊处理。


//===================================================
//===================================================

分割符号只会决定对比块的多少，不会影响差异块，因为差异块内部可能会包含分割符号（计算编辑距离时得到的）

	分隔符：只决定把原始字符串切成多少 "最小单元" ，
			然后这些单元再交给算法去比对 → 会影响 "差异块" 的粒度多少。

	差异块内部：仍然可能包含分隔符（比如 \n），
			算法在算最短编辑路径时把它当普通字符处理，
			不会因为你定义了分隔符就自动拆开。

因为在计算"算法内部的编辑距离"时，它会把\n也会当成 普通字符串放在其中，肉眼不能直接看出差异块的。



