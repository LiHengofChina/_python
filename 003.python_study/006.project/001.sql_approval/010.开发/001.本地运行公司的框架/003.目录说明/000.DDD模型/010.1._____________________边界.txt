

//===================================================== domain
//===================================================== domain

leave
	-entity
	-event
	-repository
	-service


person
	-entity
	-repository
	-service

//=====================================================
//=====================================================

逻辑边界："微服务内聚合" 之间的边界是 "逻辑边界"。
		  它是一个虚拟的边界，强调 "业务的内聚"，
		  可根据需要变成物理边界，也就是说聚合也可以独立为微服务。

物理边界：微服务之间的边界是物理边界。
		  它强调微服务部署和运行的隔离，
		  关注微服务的服务调用、容错和运行等。

代码边界：不同层或者聚合之间代码目录的边界是代码边界。
		  它强调的是代码之间的隔离，方便架构演进时代码的重组。



通过以上边界，我们可以让业务能力 "高内聚"、"代码松耦合"，且 "清晰的边界"，
可以快速实现 "微服务代码" 的 "拆分和组合"，
轻松实现 "微服务架构演进"。

//但有一点一定要格外注意，边界清晰的微服务，不是大单体向小单体的演进。



//===================================================== 注意：
//===================================================== 注意：

第一点：聚合之间的代码边界一定要清晰。
		"聚合之间" 的服务调用和数据关联应该是尽可能的松耦合和低关联，

		聚合之间的服务调用应该通过上层的应用层组合实现调用，
		原则上不允许聚合之间直接调用领域服务。这种松耦合的代码关联，
		在以后业务发展和需求变更时，可以很方便地实现业务功能和聚合代码的重组，
		在微服务架构演进中将会起到非常重要的作用。

第二点：你一定要有代码分层的概念。写代码时一定要搞清楚代码的职责，
		将它放在职责对应的代码目录内。
		应用层代码主要完成服务 "组合和编排"，
		以及聚合之间的协作，它是很薄的一层，不应该有 "核心领域" 逻辑代码。
		
		"领域层" 是业务的核心，
		领域模型的 "核心逻辑代码" 一定要在 "领域层" 实现。
		如果将核心领域逻辑代码放到应用层，
		你的基于DDD分层架构模型的微服务慢慢就会演变成传统的三层架构模型了。






