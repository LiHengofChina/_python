
//=====================================================================================================（1）需求
//=====================================================================================================（1）需求

SQL审核的目标对象 ，可以给每个 "目标对象" 创建一个 "连接池" ，
里面放 "2到3个连接" ，规则那里改成 "多线程" 。
给每个目标对象（数据库）单独建一个 小型连接池（ 2 ~ 3 个连接），
再让规则执行部分用 多线程并发审核 ——这样每个线程都能立即复用连接，不用等待创建连接的耗时。

//=====================================================================================================（2）分析
//=====================================================================================================（2）分析

Spring Boot本身 使用了 HikariCP，
我现一个内存Map ，key使用对象id,值为 多个 HikariCP 对象，每个对象创建2个连接，

Map<Long, HikariDataSource> connectionPoolMap;
hikariDataSource.setMaximumPoolSize(3);
hikariDataSource.setMinimumIdle(2);

		ey： 目标对象 ID（对应数据库实例）
	 value： 一个独立的 HikariDataSource，即该对象的连接池，每个池子配置 2~3 个连接，比如：

//=====================================================================================================（3）注意事项：
//=====================================================================================================（3）注意事项：

（1）池子本身要长期存在，不要频繁关闭。
（2）设置连接超时与空闲回收，最多空闲1个连接，最多3个连接。

//=====================================================================================================（4）多线程
//=====================================================================================================（4）多线程

每个 "目标对象" 拥有自己的连接池，互不干扰，不需要 "频繁创建销毁连接"。
规则 "多线程执行" 时可以 "复用连接"，极大提高并发性能，容易统一管理。

//=====================================================================================================（5） 锁
//=====================================================================================================（5） 锁

每个规则都是 独立线程执行，并且每个线程只使用自己独立的连接（或者独立的连接池），
那么它们之间 资源互不共享、不写同一对象，自然也就 不需要加锁。

//=====================================================================================================（6）事务问题
//=====================================================================================================（6）事务问题

HikariCP 本身不控制事务，它只负责高效地管理连接。
事务的控制（开启、提交、回滚）依然是由 你上层的代码或 Spring 框架 来管理的。

"事务控制" 主要用于 "写操作（修改）" 的原子性、一致性保障。

如果不会修改 "数据库状态（比如 INSERT/UPDATE/DELETE）"，
只要你的 "审核逻辑" 只是 "读数据（不涉及更新）"，就不用 "开启事务"。

"事务的主要作用" 是保证 "多条写操作（修改数据）" 的一致性；

这里主要是执行 "SELECT 查询、分析、比对规则"，这类操作 天然是幂等的，不需要事务保护；

"开启事务" 反而会导致 "额外的开销（比如关闭 autoCommit、持有连接时间更长）"。

引入「多线程 + 对象连接池」时， "每个线程" 只执行独立查询；
不需要在 "这些线程里" 显式 setAutoCommit(false)；及时关闭（或归还）连接给 HikariCP即可。


//=====================================================================================================（7）关闭连接问题
//=====================================================================================================（7）关闭连接问题

 

try (Connection connection = getConnection(target)) {//此时从连接池获取的连接
    ...
}

try  执行完块后，会自动执行： connection.close();


但在使用 HikariCP 时，这个 close() 不是真的“关闭物理连接”
 
在 HikariCP 中，Connection 实际是被代理过的（比如 HikariProxyConnection）。
当你调用 .close() 时：
	✅ 它不会销毁连接，而是把连接“放回池子里”。

