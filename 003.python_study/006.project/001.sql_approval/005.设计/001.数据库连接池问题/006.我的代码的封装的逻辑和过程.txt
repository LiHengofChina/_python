
//======================================================================  操作接口
//======================================================================  操作接口

//== 接口
//== 接口

public interface DBOperations {

    String buildJdbcUrl(TargetObject TargetObjectInfo);

    void loadDriver();

    Connection getConnection(String url, String username, String password) throws SQLException;

    default ImmutablePair<String, String> decodeCredentials(String encodedUsername, String encodedPassword) {

        return new ImmutablePair<>(decodedUsername, decodedPassword);
    }

    default <T> T executeWithConnection(String url, String username, String password, ConnectionCallback<T> callback) {
        try (Connection connection = getConnection(url, username, password)) {
            if (connection == null) {
                throw new SQLAuditBusinessException("连接失败");
            }
            return callback.doInConnection(connection);
        } catch (SQLException e) {
            throw new SQLAuditBusinessException("执行异常: " + e.getMessage(), e);
        }
    }
}

//== 实现
//== 实现

abstract class DMDatabaseOperations implements DBOperations {}
abstract class MySQLDatabaseOperations implements DBOperations {}
abstract class OBDatabaseOperations implements OBOperations {} //多了一层 interface OBOperations extends DBOperations {}
abstract class OracleDatabaseOperations implements DBOperations {}
abstract class TDSQLDatabaseOperations implements DBOperations {}


//======================================================================  执行器
//======================================================================  执行器

//== 接口
//== 接口

public interface Executor {

    String connect(TargetObject TargetObjectInfo);

    public List<String> getDatabases(TargetObject TargetObjectInfo);

    public List<String> getAuditSql(int interval ,String dbNameOrSchema,
                                    TargetObject TargetObjectInfo);

    public boolean isLoggingEnabled(TargetObject TargetObjectInfo);

    public List<String> obtainLoggingFilePath(TargetObject TargetObjectInfo, MachineInfo machineInfo);


    javax.sql.DataSource createTargetObject(TargetObject TargetObjectInfo, String dbNameOrSchema);

    List<String> getSingleFieldListBySql(TargetObject TargetObjectInfo, String sql);

    int executeSingleSql(String sql, TargetObject TargetObjectInfo, String dbName);

    Map<String, List<String>> getDatabaseObject(TargetObject TargetObjectInfo, String dbNameOrSchema);

    List<String> getNonInnoDBTables(TargetObject TargetObjectInfo, String dbNameOrSchema);
	
}


//== 实现
//== 实现

@Component("DMExecutor")
public class DMExecutor extends DMDatabaseOperations implements Executor {}
@Component("MySQLExecutor")
public class MySQLExecutor extends MySQLDatabaseOperations implements Executor {}
@Component("OBMySQLExecutor")
public class OBMySQLExecutor extends OBDatabaseOperations implements Executor {}
@Component("OBOracleExecutor")
public class OBOracleExecutor extends OBDatabaseOperations implements Executor {}
@Component("OracleExecutor")
public class OracleExecutor extends OracleDatabaseOperations implements Executor {}
@Component("TDSQLExecutor")
public class TDSQLExecutor extends TDSQLDatabaseOperations implements Executor {}



//== 工厂
//== 工厂

@Component
public class ExecutorFactory {

    private final Map<String, Executor> executorMap;

    @Autowired
    public ExecutorFactory(Map<String, Executor> connectorMap) {
        this.executorMap = connectorMap;
    }

    public Executor getSqlExecutor(Integer realType) {
        RealType rt = RealType.fromCode(realType);
        return executorMap.get(rt.getExecutorKey());
    }

}

//====================================================================== 说明 
//====================================================================== 说明 
 
（1）执行器 Executor 实现类 上加 @Component ，ExecutorFactory 会通过 Spring 容器注入这些具体的执行器（@Component）。

（2）这 6 个执行器，每个类型只会创建 一个实例。这些实例会在启动时自动注册到 Spring 容器中。

（3）6 个执行器 → 6 个单例 Bean → 由 Spring 管理，全局复用。

（4）每个执行器都继承了 Operations 操作器，实现了 Executor 接口，
		所以操作器里面的方法它可以使用

	 我想问的是这 6 个执行器对象由spring管理，它们继续的父类和接口的实现是来自哪里呢

//====================================================================== 结语
//====================================================================== 结语

要给每个对象添加连接池功能（HikariCP），
主要就是在你的 “操作器（Operations）层” 扩展实现，
因为这一层正好是负责连接建立、释放和执行流程的地方。



//========================== 目前操作器的职责是：
//========================== 目前操作器的职责是：

打开连接 → 执行 SQL → 关闭连接。
要引入连接池，只需在这里：
改为从池中获取连接（而不是每次新建）。
在系统启动/关闭时管理连接池生命周期。


改为从池中获取连接（而不是每次新建）。



