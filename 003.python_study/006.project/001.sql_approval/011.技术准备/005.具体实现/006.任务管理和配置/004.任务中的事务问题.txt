
//=========================== 我的基础层
//=========================== 我的基础层

（1）web层，提供 api 接口 

（2）基础设施层  application
		//业务逻辑实现，可以调用多个 infrastructure 的repository
		//把它们组全进来

		//另外数据库事务也是加在这一层地
		//如 这一层的实现中有的方法 我添加了     @Transactional
		//可以让它们同时失败或同时成功

（4）应用层的服务 infrastructure layer
	  这里面有 repository 和 mapper
	  通常是 repository 调用  mapper，mapper执行数据库操作

//========================= 现在我集成 了quartz
//========================= 现在我集成 了quartz

（1）有一个 TaskAuditServiceImpl 它位于 application 层
	 它里面注入了 private final Scheduler scheduler;
	 这样我就可以通过 scheduler 来实现任务的添加和删除等
	 （当然也会结果其它的repository查询一些数据组合返回）。

（2）另外我添加任务任务之后的具体任务类放在application层
	job通过调用appliction层来完成 事务相关的操作

	（1）事务1：保存任务结果表 task_result，采集sql后保存 到 task_result_sql
	（2）事务2：开始调用审核方法，但是这里的审核方法位于另一个application
	（3）事务3：更新 task_result 表、更新 task_result_sql 表、

//===================================================================== 解决办法
//===================================================================== 解决办法
//=======方法一：
//=======方法一：

保持层次分离：
		最好将 Job 中的复杂业务逻辑放到 应用层 中，
		然后通过 应用层的服务 来执行任务。
		这可以保持 Job 层作为任务调度的执行者，而 应用层 处理实际的业务逻辑。

//=======方法二：实现麻烦一点
//=======方法二：实现麻烦一点

通过事件驱动 或 异步处理：可以通过事件驱动或回调机制来解耦，
不必让 Job 直接依赖于 应用层 的服务。


//==================================================== 最终 解决办法 ：
//==================================================== 解决 解决办法 ：

将 job 移动到 application 层，然后在 job中调用它的 appliction层代码
实现主要逻辑，appliction层来提供事务支持
//这样可以：保持 Job 层作为任务调度的执行者，而 应用层 处理实际的业务逻辑。


