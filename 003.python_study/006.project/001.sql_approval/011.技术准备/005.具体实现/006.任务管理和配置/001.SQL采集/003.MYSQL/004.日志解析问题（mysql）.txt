

//============================================================= 解析位置问题
//============================================================= 解析位置问题


（1）最初从0开始解析，记录解析到的位置

		（1）0~100
		（2）100~200

（2）下次从新位置 开始解析

//============================================================= 多行SQL的问题
//============================================================= 多行SQL的问题
有些SQL在日志有会占用多行，
这时使用下一行的 "开始标记" 来区别，这条SQL是否结束，

读取一行时，记录读取之前的行，
当发现后面是结束时，使用seek跳到原来上一行的位置，
这样就让sql正常取完，同时下一次会从结束位置开始取



//============================================================= 如何锁定某条SQL是某个数据库的
//============================================================= 如何锁定某条SQL是某个数据库的


（1）. 如果 currentFilePointer 不为 0 
     1. 从后往前读取到 use ，这样就可以知道当前使用的库名的 currentDbName 的值了

			/** 实现方式
			  //=========================================== 方式一
			  （1）把 从 0 ~ currentFilePointer 的数据全部读取到 std::deque 中
					  //（1）只是use才存放 "下一次从哪里开始读取 use 信息"
					  //（2）反过来查询 use 的行。

			  //=========================================== 方式二
			  （3）这里直接存放一个有序集合，然后取它最大脚标的元素也是可以的
				   //std::list
			  //=========================================== 优化
			  //（2）这里再加一个变量：表示从哪个位置开始搜索库名
			*/

	 2. 如果没找到，则报错，说日志文件不完整
	 3. 找到之后就开始业务处理

（2）. 如果 currentFilePointer 为 0
	 1. 则直接开始处理，每次遇到 use 则更新 currentDbName 的值，
	 2. 遇到SQL处理时，则判断 currentDbName 是否是需要的 dbName 名字，是才返回，不是则放弃。
	 3. 如果处理时 currentDbName 为空，则报说，无法区分所属库

//=============================================================  怎么判断是某个库的sql
//=============================================================  怎么判断是某个库的sql

（1）use要相同
（2）日志id要相同


//============================================================= 另一个问题
//============================================================= 另一个问题
有时候明明选择的是A库，
但是有B库的操作SQL，那是因为它跨库操作了。

//这种操作日是合理的


//============================================================= mysql 查询中记录所有的SQL
//============================================================= mysql 查询中记录所有的SQL


			

包括 编写错误的SQL也会记录其中对吗
所有执行的

比如 ：UPDATE `course` SET course_name = 'Mathx' WHERE id=1
我写成了：UPDATE `course` SET course_name = `Mathx` WHERE id=1

它也会被 记录到查询日志里面是吗

//======================================（1）
MySQL 的查询日志会记录所有执行的 SQL，包括正确和错误的 SQL 查询。
//查询日志仍然会包含这条 SQL 查询，记录了你尝试执行的 SQL。
 （1）字符串使用了``反引号，而不是''单引号
		如：UPDATE `course` SET course_name = `Mathx` WHERE id=1
		/**
		在校验之前 改写sqlNode，把 常量的反引号``，修改为 单引号''

			（1）遍历语法树
			（2）对值 带反引号的 进行判断 
					if(是元数据){
						保持不变
					}else{
						修改为单引号
					}
			（3）执行验证
			（4）继续后续逻辑
		*/


 （2）字符串没加 '' 号，也会当成其它字段

 （3）另外用户有时候写的是测试SQL,里面的字段和表名不存在，
		 会导致校验失败，关闭不了。
		 如：UPDATE `course` SET course_namexx = `id` WHERE id=1

  //======================
  以上都直接抛出错误:

  如果 "验证不通过" ，就相当于 "审核不通过"



