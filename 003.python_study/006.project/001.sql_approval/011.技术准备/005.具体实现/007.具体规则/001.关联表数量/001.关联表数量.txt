

这里面其实有好几个概念

	（1）单次关联表数量（横向），
				/**
					分析：要关联表，肯定是在Form后面

					所以只有能遍历SqlNode的所有节点
					（包括子节点的办法）
					（如果没有这个方法我自己写一个），
					判断它是 SqlSelect 类型
					然后取Form，然后计算数量就可以了

					这样的好处是
							（1）不用考虑深度
							（2）不用考虑出现的位置
							（3）不用考虑数量
				*/
				//要关联表，一定是在

	（2）子查询总数量
				//这个也和第一条规则实现同理


	（3）连续嵌套层数（纵向）
				/**
				我的想法是SqlNode， 它是一棵树（二叉树，N叉树这种）形结构吗

				如果是，可以以任何节点为根节点，遍历它的子节点，
				只要有一个子节点数超过（某个阈值）就不合格

				既然有一个 "超过" 就 "不合格"，
				那么 "本身根节点" 的 "子节点" 最多，
				所以我只遍历根节点的最远子节点就好了，如果它超过（某个阈值）就不合格

				*/






为了 "实现方便"，这三个都应该是独立的审核规则，这样去审核才有现实意义
所以我应该分别实现这三个审核项



//==========================================================
//==========================================================


规则：多表关联 JOIN 子句中涉及的表数量不能超过阈值
描述：当一次查询涉及的表过多时，数据库需要进行更多的连接操作，可能导致查询的执行效率降低。因此，限制每个查询的最大关联表数量有助于提升查询的效率和可读性。


规则：SELECT 嵌套层数不能超过 阈值 
描述：当 SQL 查询的嵌套层数过多时，执行计划的生成可能变得复杂，导致性能下降。多层嵌套会增加数据库的查询负担，降低查询效率，因此建议限制嵌套层数，确保查询能够在合理的时间内执行完毕。


规则：SQL 查询中的子查询总数量不能超过 阈值
描述：子查询的过多使用可能会导致查询变得难以优化，从而影响查询性能。每个子查询都需要额外的计算资源和内存，过多的子查询会加重数据库负担，降低系统的响应速度。为确保系统性能，建议限制 SQL 查询中的子查询数量。



max_join_table_count

max_select_nesting_depth

max_subquery_quantity


