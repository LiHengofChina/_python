
#!/bin/bash

//==========================================================
//==========================================================

# 设置 compose 文件路径（可传参）
COMPOSE_FILE=${1:-docker-compose.yml}
		// 指向编排文件 compose 的位置

ARCH_TAG=${2:-amd64}         # 架构标记（如 arm64）
		//一个标记：当前生成什么架构的后缀标记
		//最后会追加到 tar 的包名上面

ARCH="linux/$ARCH_TAG"       # 完整平台（如 linux/arm64）

		/**

		🐠COMPOSE_FILE = ../../docker-compose/docker-compose-base-env.yaml
		🈏 ARCH_TAG     = amd64
		🐠ARCH         = linux/amd64

		*/

//==========================================================
//==========================================================

if [ ! -f "$COMPOSE_FILE" ]; then
    echo "❌ 未找到 docker-compose 文件: $COMPOSE_FILE"
    exit 1
fi
		//判断 编译文件是否存在

//==========================================================
//==========================================================

# 提取 image 列表
IMAGES=$(grep 'image:' "$COMPOSE_FILE" | awk '{print $2}' | sed 's/"//g' | sed "s/'//g")

		/**
			示例：

			IMAGES=$(grep 'image:' "../../docker-compose/docker-compose-base-env.yaml" | awk '{print $2}' | sed 's/"//g' | sed "s/'//g")

				（1）grep 找到所有包含 image: 的行
				（2）awk '{print $2}' 提取第二列（真正的镜像名）
				（3）sed 去掉可能存在的引号
				（4）得到 IMAGES 是一个 普通的 shell 字符串
					 里面的多个镜像条目以 换行符（\n） 分隔。
					 示例1：
						192.168.100.16:18888/hubdocker/mysql:8.0.32 
						192.168.100.16:18888/hubdocker/nacos/nacos-server:v2.4.3 
						192.168.100.16:18888/hubdocker/apache/rocketmq:5.3.1 
						192.168.100.16:18888/hubdocker/apache/rocketmq:5.3.1 
						192.168.100.16:18888/hubdocker/seataio/seata-server:2.0.0

					 示例2：
						192.168.100.16:18888/rkzl/microservices-gateway:main-5faffa816343f038dc8ec74a43bec0b6f23d7e01-20251021030230
						192.168.100.16:18888/rkzl/microservices-user-auth:main-74ef5e72c9237c9f48f70120c72b6a6c6259a07e-20250930062302
						192.168.100.16:18888/rkzl/console:microservices-234f561134b438be16dcb6389f8607905cb45e71-20250702092513
						192.168.100.16:18888/rkzl/console-web:customer_chongqing_xinyujinrong-a8083ab95666eabf22e54e30927f622fa030d0f9-20250925015956
						192.168.100.16:18888/rkzl/microservices-sqlaudit:main-7a121984cd889da7717f4bad7ccfc9e4c189c658-20251125144744
						192.168.100.16:18888/rkzl/microservices-sql-guard-web:main-7b84bba1766da51d5f66c9ffe39198d1a99e35cd-20251128160211

		*/


//==========================================================
//==========================================================

for IMAGE in $IMAGES; do

    echo "📦 处理镜像: $IMAGE"
	//========================================================== tag
	//========================================================== tag

    tag="${IMAGE##*:}"
		//从 $IMAGE 变量中，取最后一个 : 之后的内容（即镜像的 tag 部分）。

		示例1：
			8.0.32
			v2.4.3
			5.3.1
			5.3.1
			2.0.0

		示例2：
			main-5faffa816343f038dc8ec74a43bec0b6f23d7e01-20251021030230
			main-74ef5e72c9237c9f48f70120c72b6a6c6259a07e-20250930062302
			microservices-234f561134b438be16dcb6389f8607905cb45e71-20250702092513
			customer_chongqing_xinyujinrong-a8083ab95666eabf22e54e30927f622fa030d0f9-20250925015956
			main-7a121984cd889da7717f4bad7ccfc9e4c189c658-20251125144744
			main-7b84bba1766da51d5f66c9ffe39198d1a99e35cd-20251128160211


	//========================================================== registry_candidate
	//========================================================== registry_candidate
    registry_candidate="${IMAGE%%/*}"
		//截取仓库地址候选部分
		/**
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
			192.168.100.16:18888
		*/

	//========================================================== registry 和 rest
	//========================================================== registry 和 rest

    if [[ "$registry_candidate" == *.* || "$registry_candidate" == *:* ]]; then

	//==========================================================
	//==========================================================

	根据  registry_candidate  判断，只要包含 . 或 : 就认为它是私有仓库，
	如：
		✔ 为什么这样判断？

		因为 Docker 私有仓库地址通常包含：
		点（.）：域名 或 IP
		冒号（:）：端口号

		而官方 Docker Hub 的镜像名称 通常没有 . 或 :。

	//========================================================== 拆成 registry 和 rest？
	//========================================================== 拆成 registry 和 rest？


		if [[ "$registry_candidate" == *.* || "$registry_candidate" == *:* ]]; then
			registry="$registry_candidate" // 192.168.100.16:18888
			rest="${IMAGE#*/}"
		else
			registry="docker.io"   // docker.io
			rest="$IMAGE"
		fi

	//==========================================================
	//==========================================================
	registry 和 rest 的值如：
	192.168.100.16:18888
	192.168.100.16:18888
	192.168.100.16:18888
	192.168.100.16:18888
	192.168.100.16:18888
	rkzl/microservices-sql-guard-web:main-7b84bba1766da51d5f66c9ffe39198d1a99e35cd-20251128160211
	rkzl/microservices-sql-guard-web:main-7b84bba1766da51d5f66c9ffe39198d1a99e35cd-20251128160211
	rkzl/microservices-sql-guard-web:main-7b84bba1766da51d5f66c9ffe39198d1a99e35cd-20251128160211
	rkzl/microservices-sql-guard-web:main-7b84bba1766da51d5f66c9ffe39198d1a99e35cd-20251128160211
	rkzl/microservices-sql-guard-web:main-7b84bba1766da51d5f66c9ffe39198d1a99e35cd-20251128160211


	//==========================================================
	//==========================================================


    repo="${rest%%:*}"
    repo_flat=$(echo "$repo" | tr '/' '+')
    repo_lower=$(echo "$repo_flat" | tr '[:upper:]' '[:lower:]')
    host=$(echo "$registry" | cut -d':' -f1)
    port=$(echo "$registry" | cut -d':' -f2)

	//========================================================== 上面9个变量，主要都是为了定义包名
	//========================================================== 上面9个变量，主要都是为了定义包名



    # 构建 tar 包名
    TAR_NAME="${host}_${port}__${repo_lower}__${tag}__${ARCH_TAG}.tar"
    TAR_PATH="${TAR_NAME}"

    echo "📦 镜像文件路径: $TAR_PATH"

    # ✅ 判断 tar 是否存在，避免重复保存
    if [ -f "$TAR_PATH" ]; then
        echo "🟡 已存在 tar 文件，跳过: $TAR_NAME"
        continue
    fi


	//========================================================== 创建一个临时 Dockerfile
	//========================================================== 创建一个临时 Dockerfile
    # ✅ 判断镜像是否已经构建过（防止重复构建）
    echo "🚀 构建 $ARCH 架构镜像..."
    TMP_DOCKERFILE="Dockerfile"

    echo "FROM --platform=$ARCH $IMAGE" > "$TMP_DOCKERFILE"
		//覆盖写入

		//生成一个只有一行的 Dockerfile
		这个 Dockerfile 的目的：
		✔ 强制 Docker 使用指定平台（arm64 / amd64）
		✔ 拉取指定镜像作为“基础镜像”，然后重新构建并导入本机

		// "请使用这个镜像作为基础镜像构建一个兼容本机的平台版本。"
		/**
		示例：
		 //==========================================================	
		 //==========================================================	

		 FROM --platform=linux/arm64 192.168.100.16:18888/rkzl/microservices-sqlaudit:main-7a121984cd889da7717f4bad7ccfc9e4c189c658-20251125144744

			告诉 buildx：如果 xxx 镜像有多个架构版本（manifest list），就选择 amd64 版本来拉取。

		 CI中本身就有两个镜像了，一个ARM、一个X86的


		 //==========================================================
		 //==========================================================

		 示例：
			FROM --platform=linux/amd64 xxx
			拉取  xxx linux/amd64 怎么来构建
		 //========================================================== 在harbar中找到它
		 //========================================================== 在harbar中找到它
			192.168.100.16:18888/rkzl/microservices-sqlaudit:main-7a121984cd889da7717f4bad7ccfc9e4c189c658-20251125144744
			项目：rkzl
			仓库：microservices-sqlaudit
			Tag：main-7a121984cd889da7717f4bad7ccfc9e4c189c658-20251125144744
					//main-7a121984cd889da7717f4bad7ccfc9e4c189c658-20251125144744 是仓库中完整的tag

			//菜单 : 项目 > rkzl > rkzl/microservices-sqlaudit >  


		*/


	//==========================================================
	//==========================================================

    docker rmi "$IMAGE"

	//从本地 Docker 镜像仓库删除名为 $IMAGE 的镜像

	//==========================================================
	//==========================================================

    docker buildx build --platform "$ARCH" \
        -f "$TMP_DOCKERFILE" \
        -t "$IMAGE" \
        --load \
        .

		/**
			使用临时 Dockerfile，从远程仓库拉取指定架构的镜像，然后重新生成一个同名镜像，加载到本地。

			--platform		//指定构建使用的架构，
			-f				//指定 Dockerfile 路径。
			-t  			//给构建出的镜像打标签（tag）

		*/

		/** 为什么这里要 docker buildx build
			因为：远程仓库（Harbor）里的镜像是 “多架构组合镜像”（multi-arch manifest），
			microservices-sqlaudit:TAG
			  ├─ amd64 镜像（artifact A）
			  └─ arm64 镜像（artifact B）

			docker save image:TAG

			Docker 只会保存你当前机器架构对应的那一个镜像（amd64），
			而 arm64 的那个镜像根本不会被保存下来！

			所以我们才需要 buildx：
			✔ buildx 可以从 manifest 中 强制选择某一个架构（amd64 / arm64）
			✔ buildx 会把该架构的镜像层真正拉下来

		*/

	//========================================================== 判断是否成功
	//========================================================== 判断是否成功
    if [ $? -ne 0 ]; then
        echo "❌ 构建失败: $IMAGE"
        rm -f "$TMP_DOCKERFILE"
        continue
    fi

	//========================================================== 删除临时的 dockerfile
	//========================================================== 删除临时的 dockerfile

    rm -f "$TMP_DOCKERFILE"

	//========================================================== 
	//==========================================================

    # 💾 保存镜像
    echo "💾 保存镜像为: $TAR_PATH"
    docker save -o "$TAR_PATH" "$IMAGE"

	//镜像保存成一个 .tar 文件

	//==========================================================
	//==========================================================

done

echo "✅ 所有镜像处理完成，保存目录: ."

