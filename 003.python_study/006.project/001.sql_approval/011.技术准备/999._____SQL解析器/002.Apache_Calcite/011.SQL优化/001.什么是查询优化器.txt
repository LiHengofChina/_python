

https://www.cnblogs.com/wcgstudy/p/11795952.html


//===================================================== 什么是查询优化器
//===================================================== 什么是查询优化器

查询优化器是传统数据库的核心模块，也是大数据计算引擎的核心模块，
开源大数据引擎如 Impala、Presto、Drill、HAWQ、 Spark、Hive 等都有自己的查询优化器。
Calcite 就是从 Hive 的优化器演化而来的。

优化器的作用：将解析器生成的关系代数表达式转换成执行计划，
供执行引擎执行，在这个过程中，会应用一些规则优化，
以帮助生成更高效的执行计划。

//==========================（1）基于规则优化（RBO）
//==========================（1）基于规则优化（RBO）
基于规则的优化器（Rule-Based Optimizer，RBO）：
根据优化规则对关系表达式进行转换，
这里的转换是说一个关系表达式经过优化规则后会变成另外一个关系表达式，
同时原有表达式会被裁剪掉，
经过一系列转换后生成最终的执行计划。

RBO 中包含了一套有着严格顺序的优化规则，
同样一条 SQL，
无论读取的表中数据是怎么样的，最后生成的执行计划都是一样的。
同时，在 RBO 中 SQL 写法的不同很有可能影响最终的执行计划，
从而影响执行计划的性能。

//==========================（2）基于成本优化（CBO）
//==========================（2）基于成本优化（CBO）
基于代价的优化器(Cost-Based Optimizer，CBO)：
根据优化规则对关系表达式进行转换，
这里的转换是说一个关系表达式经过优化规则后会生成另外一个关系表达式，
同时原有表达式也会保留，经过一系列转换后会生成多个执行计划，
然后 CBO 会根据统计信息和代价模型 (Cost Model) 计算每个执行计划的 Cost，
从中挑选 Cost 最小的执行计划。

由上可知，CBO 中有两个依赖：统计信息和代价模型。
统计信息的准确与否、代价模型的合理与否都会影响 CBO 选择最优计划。
从上述描述可知，CBO 是优于 RBO 的，原因是 RBO 是一种只认规则，
对数据不敏感的呆板的优化器，而在实际过程中，数据往往是有变化的，
通过 RBO 生成的执行计划很有可能不是最优的。
事实上目前各大数据库和大数据计算引擎都倾向于使用 CBO，
但是对于流式计算引擎来说，使用 CBO 还是有很大难度的，因为并不能提前预知数据量等信息，
这会极大地影响优化效果，CBO 主要还是应用在离线的场景。


//========================== 优化规则
//========================== 优化规则
（1）谓词下推 Predicate Pushdown
（2）常量折叠 Constant Folding
（3）列裁剪 Column Pruning
（4）其他

在 Calcite 的代码里，
有一个测试类（org.apache.calcite.test.RelOptRulesTest）汇集了对目前内置所有 Rules 的测试 case，
这个测试类可以方便我们了解各个 Rule 的作用。
在这里有下面一条 SQL，
通过这条语句来说明一下上面介绍的这三种规则。


