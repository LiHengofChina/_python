package main	//当前 Go 程序的包名，表示这是程序入口包。

		//package main = 这是一个可以被编译成可执行文件的入口包。

		/**
			Go 规定：
				必须是 package main
				必须有 func main()
				才能生成可执行程序。
			其他包（utils、cmd 等）都不能作为入口。
		*/



//======================================================== 导入其它 Go 依赖（包）。
//======================================================== 导入其它 Go 依赖（包）。

import (

	//===================================== Go 官方自带的库：
	//===================================== Go 官方自带的库：
	"embed"				//把目录/文件打包进二进制
	"fmt"				//打印输出、格式化字符串	
	"io/fs"				//文件系统抽象（遍历嵌入目录用）
	"os"				//文件、目录、系统操作
	"path/filepath"		//处理路径（拼接、相对路径）

	//===================================== Go 官方自带的库：
	//===================================== Go 官方自带的库：
	"gitee.com/skahhl/dockermgr/cmd"
			/**
				Go 的 import 不是用你电脑的文件路径！
				而是使用 go.mod 中声明的 module 路径。
				
				在 go.mod 中，项目的逻辑路径是 module gitee.com/skahhl/dockermgr 
				
				整个项目的根路径，就是 gitee.com/skahhl/dockermgr
			*/
			

)


//========================================================
//======================================================== 


//go:embed install/*
var embeddedInstall embed.FS


/**
把整个 install 目录嵌入（打包）到程序内部，并存到 embeddedInstall 这个变量里。


非常重要，而且用法很固定。
*/


//========================================================
//========================================================



func extractInstallDir(targetDir string) error {

	/**
		WalkDir 用来“遍历目录树”，对目录里的每个文件和子目录执行一次回调函数。
			✔ 递归列出目录内所有内容
			✔ 包括目录
			✔ 包括文件
			✔ 包括子目录
			✔ 会依次调用你写的函数（匿名函数）
	*/

	return fs.WalkDir(
				embeddedInstall,	// 要遍历的 "文件系统"
				"install",			// 从这个目录开始遍历
				func(path string, d fs.DirEntry, err error) error { //回调函数

					//=========================================
					//=========================================
					if err != nil {
						return err
					}
					//return err → 把错误往外抛
					//让外层知道失败了


					//把 "嵌入文件的路径" 转换成 "相对路径"。
					relPath, err := filepath.Rel("install", path)
					if err != nil {
						return err
					}

					//========================================= 拼接目录，改变权限
					//========================================= 拼接目录，改变权限
					dstPath := filepath.Join(targetDir, "install", relPath)
					if d.IsDir() {
						return os.MkdirAll(dstPath, 0755)
					}

					//========================================= 重新创建一个文件，并把 embed 里读取的内容写进去。
					//========================================= 重新创建一个文件，并把 embed 里读取的内容写进去。
					data, err := embeddedInstall.ReadFile(path)
					if err != nil {
						return err
					}
					return os.WriteFile(dstPath, data, 0755)
				}
	)
}

func main() {
	// 每次启动先把 install 目录释放出来（可选，看你是否需要执行 sh）

	//======================================================== 获取当前路径
	//======================================================== 获取当前路径
	currentDir, _ := os.Getwd()//就是获取 dockermgr 运行时的当前工作目录。

	//======================================================== 创建新目录
	//======================================================== 创建新目录
	targetInstallDir := filepath.Join(currentDir, "install")
	//在当前运行目录下，拼出一个 "install" 目录的完整路径。
	//这个路径就是稍后 "释放 install 目录（）"的目标位置。


	// Stat 获取文件状态，判断 IsNotExist状态
	if _, err := os.Stat(targetInstallDir); os.IsNotExist(err) {


		//================================================打印语句
		fmt.Println("正在释放 install 目录...")


		if err := extractInstallDir(currentDir); err != nil {
			fmt.Println("释放 install 目录失败:", err)
			os.Exit(1)
		}

	}

	//=================================================== 调用 root.go 里面的 Execute
	//=================================================== 调用 root.go 里面的 Execute
	cmd.Execute()
}



//========================================================================================== 注意事项 
//========================================================================================== 注意事项 

（1）
	//go:embed install/* 是编译指令（Compile-time 指令）
	作用：
	在编译 docker-mgr 的时候，把 install 目录整个打包进 docker-mgr 二进制文件里。



（2）而
	fs.WalkDir(
		embeddedInstall,
		"install",
		func(path string, d fs.DirEntry, err error) error {}
	)
	的作用是
	在 docker-mgr 是在运行时把它解压到目标目录
	


