https://blog.csdn.net/2301_76848549/article/details/134963698


并查集：
	是一种用于管理 "元素的集合" 的 "数据结构"
	它主要用于解决集合的 "动态连接性" 问题。

	即在一组元素中，判断 "两个元素" 是否属于"同一个集合（指子集合）"
	并且可以合并两个集合。


在并查集中，集合的 "成员之间的关系" 是通过 "树状结构" 来表示的，
	其中 "每个树的根节点代表" 一个集合。
	而树中的其他节点代表集合中的成员。

因此，并查集可以有效地实现集合的 "划分和管理" ，能够快速地支持 "查找和合并" 操作。	


所以 是一种数据结构，用于管理元素之间的集合关系


//================================================ 举例：
//================================================ 举例：



假设有一组人员，编号为 0 到 6，
我们想要对他们进行集合划分（把有联系的划分成一个子集体），
以便快速确定某两个人是否属于同一个集合。

（1）初始情况下，每个人都属于自己独立的集合，即 "每个人的父节点都是自己"。
		0  1  2  3  4  5  6

（2）现在，假设我们知道:
		a）. 0 和 1 有联系
		b）. 1 和 2 有联系
		c）. 3 和 4 有联系

		0  1  2  3  4  5  6
		|  |     |
		1  2     4

现在，我们可以通过并查集快速确定某两个人是否在同一个集合（子集合）中

例如，我们想要知道 0 和 3 是否在同一个集合中。
我们可以逐步查找它们的父节点，如果它们的根节点相同，
则表示它们在同一个集合中。
具体查找步骤如下：

（1）查找 0 的根节点：0 -> 1 -> 2， 根节点为 2。
（2）查找 3 的根节点：3 -> 4， 根节点为 4。
（3）根节点不同，因此 0 和 3 不在同一个集合中。


//================================================ 时间换空间
//================================================ 时间换空间

它是一种时间换空间的方式

并查集中，通过维护一个父节点数组，每个元素都有一个指向其父节点的指针。
这种数据结构可以在常数时间内进行查找操作（找到元素所在集合的根节点），因此查找操作的时间复杂度是 O(1)。
但是，在进行合并操作时，可能需要修改树的结构，这可能会导致一些额外的时间开销，因此合并操作的时间复杂度通常是接近于 O(log n) 的。


与时间复杂度相比，使用并查集通常会节省大量的空间。
例如，在实现图的连通性检查时，
可以使用并查集而不是邻接矩阵或邻接表来存储图的连接关系，这样可以节省大量的空间。

因此，并查集是一种以时间换取空间的数据结构，
在某些场景下可以提供更好的性能和更低的空间消耗。

