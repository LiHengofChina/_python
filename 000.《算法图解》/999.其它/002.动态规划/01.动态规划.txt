

//=========================================================================
//=========================================================================
动态规划（Dynamic Programming，简称 DP）是一种 "常见的问题" 求解方法，
通常用于 "优化问题" 。

它通常用于解决 "具有重叠子问题" 和 "最优子结构" 性质的问题，

通过将问题 "分解成更小的子问题"，然后通过解决这些子问题来解决原始问题。



动态规划通常包含以下步骤：

（1）定义状态： 
		首先要确定问题的状态，也就是解决问题时需要 "记录的信息"。
		"状态的选择" 对问题的解决至关重要，
		状态应该包含 "问题的全部信息"，且 "状态的数量" 应该尽可能少。

（2）设置状态转移方程：  "状态转移方程" 描述了不同状态之间的转移关系，
		即如何 "根据已知状态" 计算出 "新的状态"。
		通过 "状态转移方程"，可以将 "大问题" 拆分为 "若干个子问题"，
		并根据 "子问题的解" 逐步推导出 "整体问题的解"。

（3）确定边界条件：边界条件是指最小规模的子问题的解
		通常是一些基本情况或者初始状态。
		在动态规划中，需要确保边界条件能够被正确处理，以防止出现越界或其他错误。

（4）自底向上求解问题：
		根据状态转移方程，从较小的子问题开始，逐步计算出更大规模的问题的解。
		通常采用迭代的方式，依次计算出各个状态对应的值，直到计算出整个问题的解。

（5）	返回结果： 最终得到整个问题的解，
		通常是通过状态转移方程计算得到的某个状态的值，或者是最终状态的值。



动态规划通常适用于具有最优子结构性质的问题，
即问题的最优解可以通过子问题的最优解推导而来。
这种性质保证了动态规划算法的正确性，
使得通过解决子问题可以得到整体问题的最优解。


//======================================================= 举例：斐波那契数列
//======================================================= 举例：斐波那契数列

斐波那契数列是一个经典的数学问题，其定义如下：

第 0 项为 0。
第 1 项为 1。
从第 2 项开始，每一项都等于前两项之和。

因此，斐波那契数列的前几项是：0, 1, 1, 2, 3, 5, 8, 13, 21, ...

用动态规划来解决这个问题：

（1） 定义状态
	  令 dp[i] 表示斐波那契数列的第 i 项。

（2） 设置状态转移方程
	  根据斐波那契数列的定义，
	  可以得到状态转移方程为 dp[i] = dp[i-1] + dp[i-2]，
	  其中 dp[0] = 0，dp[1] = 1。

（3） 确定边界条件： 边界条件即初始状态，
	  即 dp[0] = 0，dp[1] = 1。

（4）自底向上求解问题： 
	  根据状态转移方程，从 dp[2] 开始逐步计算出 dp[3]、dp[4]，直到 dp[n]，
	  其中 n 是我们要计算的斐波那契数列的项数。

（5）返回结果： 最终得到 dp[n] 即为斐波那契数列的第 n 项的值。


	public class Fibonacci {

		public static int fibonacci(int n) {


			if (n <= 1) {
				return n;
			}
			
			int[] dp = new int[n + 1];
			dp[0] = 0;
			dp[1] = 1;
			
			for (int i = 2; i <= n; i++) {
				dp[i] = dp[i - 1] + dp[i - 2];
			}

			return dp[n];
		}

		public static void main(String[] args) {
			int n = 16;
			System.out.println("斐波那契数列的第 " + n + " 项为：" + fibonacci(n));
		}
	}


//======================================================= 安全参考
//======================================================= 安全参考
https://blog.csdn.net/2301_76848549/article/details/136072771


//=======================================================
//动态规划像不像递归轮回
//=======================================================
动态规划与递归确实有一些相似之处，但也有明显的区别。

（1）相似之处：
					1）重叠子问题：动态规划和递归都可以处理包含重叠子问题的问题。
							动态规划通常使用一个表格来存储已经解决的子问题的结果，避免重复计算，
							而递归则通过函数调用自身来处理重叠子问题。
					2）自相似性：
							在递归和动态规划中，问题的解决方案通常与其子问题的解决方案相似。
							动态规划可以利用这种相似性来有效地解决问题，避免重复计算。

（2）区别之处：
					1）状态的存储：
							动态规划通常使用数组或矩阵等数据结构来存储问题的解，
							而递归则通过函数调用的堆栈来存储状态信息。

					2）自底向上 vs. 自顶向下：动态规划通常采用自底向上的方法，
							从最小的子问题开始逐步解决，直到解决原始问题。
							而递归通常采用自顶向下的方法，从原始问题开始，
							递归地解决子问题，直到达到最小的基本情况。
					3）效率：动态规划通常比纯递归更高效，
							因为它避免了递归的重复计算，
							并且以迭代的方式解决问题。
							
虽然动态规划和递归有一些相似之处，但它们的实现方式和解决问题的思路不同。
在很多情况下，动态规划能够提供更有效的解决方案，
特别是对于包含重叠子问题的问题。

//=======================================================
//动态规划为什么叫这个名字呢
//=======================================================

	"动态规划"这个术语是由美国数学家理查德·贝尔曼（Richard Bellman）在20世纪50年代提出的。
	他在解决 "多阶段决策" 过程中的最优化问题时，提出了这一概念。

	起初，贝尔曼将其称为"递推法"（"The Principle of Optimality"），并在早期的工作中使用了这个术语。
	但后来，他发现了一种更为通用的方法，可以更有效地解决更广泛的问题，因此他在后来的研究中将其称为"动态规划"。

	"动态"一词表明问题的 "解决方案" 是 "随着时间" 或 "问题规模" 的变化而变化的。
	"规划"一词表示解决方案是通过 "一系列规则或策" 略来制定的。

	因此，"动态规划"实际上是一种通过将问题分解为子问题并使用最优子结构性质来解决的方法。
	通过存储已解决子问题的结果，
	并避免重复计算，动态规划能够在更有效的时间复杂度内解决许多复杂的优化问题。


