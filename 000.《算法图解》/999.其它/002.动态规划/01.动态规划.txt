
动态规划（Dynamic Programming，简称 DP）是一种 "常见的问题" 求解方法，
通常用于 "优化问题" 。

它通常用于解决 "具有重叠子问题" 和 "最优子结构" 性质的问题，

通过将问题 "分解成更小的子问题"，然后通过解决这些子问题来解决原始问题。



动态规划通常包含以下步骤：

（1）定义状态： 
		首先要确定问题的状态，也就是解决问题时需要 "记录的信息"。
		"状态的选择" 对问题的解决至关重要，
		状态应该包含 "问题的全部信息"，且 "状态的数量" 应该尽可能少。

（2）设置状态转移方程：  "状态转移方程" 描述了不同状态之间的转移关系，
		即如何 "根据已知状态" 计算出 "新的状态"。
		通过 "状态转移方程"，可以将 "大问题" 拆分为 "若干个子问题"，
		并根据 "子问题的解" 逐步推导出 "整体问题的解"。

（3）确定边界条件：边界条件是指最小规模的子问题的解
		通常是一些基本情况或者初始状态。
		在动态规划中，需要确保边界条件能够被正确处理，以防止出现越界或其他错误。

（4）自底向上求解问题：
		根据状态转移方程，从较小的子问题开始，逐步计算出更大规模的问题的解。
		通常采用迭代的方式，依次计算出各个状态对应的值，直到计算出整个问题的解。

（5）	返回结果： 最终得到整个问题的解，
		通常是通过状态转移方程计算得到的某个状态的值，或者是最终状态的值。



动态规划通常适用于具有最优子结构性质的问题，
即问题的最优解可以通过子问题的最优解推导而来。
这种性质保证了动态规划算法的正确性，
使得通过解决子问题可以得到整体问题的最优解。


//======================================================= 举例：斐波那契数列
//======================================================= 举例：斐波那契数列

斐波那契数列是一个经典的数学问题，其定义如下：

第 0 项为 0。
第 1 项为 1。
从第 2 项开始，每一项都等于前两项之和。

因此，斐波那契数列的前几项是：0, 1, 1, 2, 3, 5, 8, 13, 21, ...

用动态规划来解决这个问题：

（1） 定义状态
	  令 dp[i] 表示斐波那契数列的第 i 项。

（2） 设置状态转移方程
	  根据斐波那契数列的定义，
	  可以得到状态转移方程为 dp[i] = dp[i-1] + dp[i-2]，
	  其中 dp[0] = 0，dp[1] = 1。

（3） 确定边界条件： 边界条件即初始状态，
	  即 dp[0] = 0，dp[1] = 1。

（4）自底向上求解问题： 
	  根据状态转移方程，从 dp[2] 开始逐步计算出 dp[3]、dp[4]，直到 dp[n]，
	  其中 n 是我们要计算的斐波那契数列的项数。

（5）返回结果： 最终得到 dp[n] 即为斐波那契数列的第 n 项的值。


	public class Fibonacci {

		public static int fibonacci(int n) {


			if (n <= 1) {
				return n;
			}
			
			int[] dp = new int[n + 1];
			dp[0] = 0;
			dp[1] = 1;
			
			for (int i = 2; i <= n; i++) {
				dp[i] = dp[i - 1] + dp[i - 2];
			}

			return dp[n];
		}

		public static void main(String[] args) {
			int n = 16;
			System.out.println("斐波那契数列的第 " + n + " 项为：" + fibonacci(n));
		}
	}


