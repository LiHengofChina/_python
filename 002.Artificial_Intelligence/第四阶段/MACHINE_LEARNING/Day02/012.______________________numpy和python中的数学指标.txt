

//================================================================================================== 算数平均值
//================================================================================================== 算数平均值
//平均值的作用：算数平均值表示——“对增值进行一个无偏估计”
dS = [S1,S2,...，Sn]
		样本中的 "每个值" 都是  "真傎与误差" 的和。

m = np.mean(array)  	#np的接口
m = array.mean()		#pandas中Series的接口
m = df.mean(axis=0)		#pandas中Dataframe的接口


//================================================================================================== 加权平均值
//================================================================================================== 加权平均值

（1）求平均值时，考虑 "不同样本" 的重要性，可以为 "不同的样本赋予不同的权重"

		//=================================== 就是说：
		（1）先给 "不同的样本" 赋予 "不同的权重" 
		（2）再去计算平均值

		//=================================== 加权平均值计算方式
		//=================================== 加权平均值计算方式
		//  "每一个样本" * "它自己的权重"  的 和 除以 "所有权重的和"

		a = (s1w1 + s2w2 + ... + snwn)/(w1 + w2 + wn )


			/**
				为什么这样可以算出加权平均值，
					因为：如果所有样本的权重值是一样的，
					s1*1 = 1  和原来的相加之后，再除以个数就是 "算术平均值"
			*/


		//================ 代码实现
		//================ 代码实现
		ap = np.average(array,weights=volumes)

				//volumes（权重列表）由自己设定
				//但有时候权重值不是我们自己设定的，
				//通过某些指标算算出来的


//================================================================================================== 最小值、最大值
//================================================================================================== 最小值、最大值
	（1）最大值  
			np.max()
	（2）最小值
			np.min()

//================================================================================================== 极差
//================================================================================================== 极差
	（1）极差
			np.ptp()		//最大值减去最不小值


//================================================================================================== 最值索引
//================================================================================================== 最值索引

搭建人工智能模型的时候，经常会用到最值索引。

	（1）np用法		//返回 "位置" 索引 ，如果返回值相同，会取前面一个
			print(np.argmax(a),np.argmin(a))

	（2）pandas中	//返回 "标签" 索引
			print(series.idxmax(),series.idxmin())		
			print(dataframe.idxmax(),dataframe.idxmin())

//==================================================================================================
//==================================================================================================
将两个同维数组中对应的元素最大/最小元素构成一个新的数组


		（1）最两个数组中对应位置 的最大值， np.maximum()
				[1 2 3 4 5 6 7 8 9 ]
				[9 8 7 6 5 4 3 2 1 ]
				_______________________________
				[9 8 7 6 5 6 7 8 9 ]	//取大的那一个

		（1）最两个数组中对应位置 的最小值， np.minimun()

				[1 2 3 4 5 6 7 8 9 ]
				[9 8 7 6 5 4 3 2 1 ]
				_______________________________
				[1 2 3 4 5 4 3 2 1 ]	//取小的那一个


				/**
					有点像 "回文"：
						上海自来水来自海上
				*/

//================================================================================================== 中位数：和平均值有点像
//================================================================================================== 中位数：和平均值有点像

多个样本，按大小排序，取中间位置的元素


	（1） 样本个数为奇数，则为中间元素
	（2） 样本个数为偶数，则为中间两个元素的平均值。
		/**
			注意：必须先排序
		*/
		/**
			有了平均值，为什么还要用中位数：

			[1,2000,3000,4000,100000] 某公司所有员工的薪资，求该公司平均薪资

			当特殊数据比较多的时候，求平均值，特殊数据一定会影响整体数据的分布状态

			所以这时候中位数就派上了用场

		*/
	//========================================== 接口
	//========================================== 接口
	np.median() 中位数


//================================================================================================== 标准差
//================================================================================================== 标准差

	标准差的作用：评估一组数据震荡的幅度。

	如果：
		标准差比较大，说明数据波形比较剧烈。
		标准差比较小，说明数据波形比较平缓。

	所以标准差，可以评估数据波动的状态

	//============================= ?
	//============================= ?
	标准差大好，还是标准差小好?

			标准差 + 平均值结合起来分析

			（1）"标准差" 比较小
			（2）且 "平均值" 比较高
			说明：又好又稳定

	//============================= 怎么求标准差 ： 标准差计算过程很复杂
	//============================= 怎么求标准差 ： 标准差计算过程很复杂


	（1）求平均值
	（2）求离差(deviation): 表示某组数据距离某个中心点偏离程序
	（3）求离差方	//因为有负数，所以(离差的平方)
	（4）方差： 	//对 "离差方"  求均值，
	（5）校准差：	//对 "方差"开根号，就是标准差//因为前面平方过


	 //============================= 总体 "方差" 、总体 "校准差"
	 //============================= 总体 "方差" 、总体 "校准差"

		总体标准差（standard deviation）:

		针对全部样本进行计算的

		如：对100万数据进行计算


	 //============================= 样本 "方差" 、样本 "校准差"
	 //============================= 样本 "方差" 、样本 "校准差"
		针对局部样本进行计算的
		取样：样本足够大的话，随机抽取样本的话，也能代表整体样本的分布状态

		少量样本，可以提高计算速度，
	//============================================================================================ 样本标准差
	//============================================================================================ 样本标准差

	全部样本的"标准差" ，本身是比较大的
	由于 "正太分布" 的原因，采样算出来的  "标准差"  ，算出来会比较小

	但是 "样本标准差" 本身是想对整体数据做出估计，

	我们可以把 "样本算出来标准差" 变大一点，
	这样就能准确的估计了。

	那么，我们把公式 的n改为n-1,以此来提高方差的值，
	称为 “贝塞尔校正系数” 。	//分母变小，整体值就会变大

	// n-1、n-2、n-3都行，就看你减多少能还原回去。

	 //============================= 使用场景 
	 //============================= 使用场景
	什么时候使用样本的、什么时候使用标准的。
	 （1）"样本数量特别多" 的时候，才会采样
	 （2） 假设 2 组数据，我们去看谁的波形幅度比较大
			这两组数据必须同时：要么都使用 "样本差" ，
			要么都使用 "校准差"

	 //============================= 接口
	 //============================= 接口

	#
	# pandas的接口         #总体标准差
	print(fracture.std())

	# numpy的接口中        #样本标准差
	print(np.std(fracture, ddof=1))  # ddof 表示贝塞尔校正系数， ddof=1 表示分母减1，  ddof=2 表示分母减2


	//============================================================================================ 其它指标，一边学习一边讲
	//============================================================================================ 其它指标，一边学习一边讲

	
	
