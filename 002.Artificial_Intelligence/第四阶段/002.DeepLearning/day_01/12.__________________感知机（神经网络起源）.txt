//======================================================== 神经网络结构
//======================================================== 神经网络结构

（1）感知机
（2）神经网络
（3）激活函数

//======================================================== 感知机
//======================================================== 感知机

（1）  "感知机（Perceptron）" ，又称为 "人工神经元（Artificial neuron）"，
它是 "生物神经元" 在计算机中的 "模拟"。

（2）  	/** 生物神经元：

			树突（收集信息）
			细胞体（处理信息）
			轴突（传递信息）
			突触（输出信息）

			//===========================过程 
			从外界接收一定的信号：达到一定阈值，
			交给神经元处理，钾纳离子放电、激活。。
			生物学神经元的

		*/




	人工神经元，它也是从外界接收信号，
	"接收到信号" 之后，进行判断，是否达到阈值，

	1）达到阈值输出一个结果，
	2）没有达到阈值输出另一个结果。

	//========================== 举例说明：生物神经元
	//========================== 举例说明：生物神经元
	你现在出去游玩，突然飞来一只蝴蝶


	然后你会判断：
		蝴蝶：的出现是否达到伤害你的阈值，没有达到，你就不会逃跑
		蜜蜂：出现会达到伤害你的阈值，你就会逃跑

	对于 "人工感知机" 也是一样的。

	"外界输入的信号" 不一样，最终判断 "处理的结果" 也是不一样的。


（3）生物神经网络
    生物神经网络
	更多的 "生物神经元" 相连接，形成复杂的神经网络，
	人类的神经元数量是 10^11 数量级。

	//神经元越多，它的处理问题的能力越强
	海绵、蚂蚁、蜜蜂、青蛙、章鱼、人类，这些生物的神经元数量是不同的，
	//人类最多。  10^11 数量级



（4）感知机（Perceptron），
	 又称为神经元（Neuron，对生物神经元进行了模仿），
	 它是 "神经网络（深度学习）"的起源算法，

		它可以接收 "多个输入信号" ，产生 "一个输出信号"（只能做线性可分的任务）
		
//========================================================================================== 感知机计算套路
//========================================================================================== 感知机计算套路
		
		//==============================================================================================（重点）简单分类任务
		/** 感知机分类：
			（蝴蝶）x1（0.2） --> w1													----------------- 0 分类（不跑）
									-----> （伤害阈值）Thea（0.4） -------->y-------->达到0.4
			（蜜蜂）x2（0.5） --> w2													----------------- 1 分类（要跑）


			//=================================== 有以下几种情况：
			（1） 蝴蝶来了0.2 
					1 *  0.2  + 0 * 0.5 = 0.2 , 小于 0.4 出结论，不跑

			（2） 蜜蜂来了0.5  
					0 *  0.2  + 1 * 0.5 = 0.5,  大于 0.4 出结论，要跑

			（3） 蝴蝶蜜蜂仪器来了
					1 *  0.2  + 1 * 0.5 = 0.7,  大于 0.4 出结论，要跑

			//=================================== 计算公式：
				x1 * w1 + x2 *w2 然后与 Thea比较

				x1 和 x2 是输入数据
				w1 和 w2 就是每个输入数据的权重值



		*/
		//==============================================================================================（重点）回归任务
		/** 
			感知机做回归：得到的是连续的值

			y = w1x1 + w2x2 - Thea  这样得到的就是连续的值。

			y = x1w1 + x2w2 + k

			所以：从这里可以看出，它是一个线性模型，所以 "感知机的本质" 就是 "线性模型"。

		*/
		//========================================================  "感知机" 的本质
		//========================================================  "感知机" 的本质

		y = w1x1 + w2x2 - Thea  这样得到的就是连续的值。

		y = x1w1 + x2w2 - b

		y = x1w1 + x2w2 + k

		所以：从这里可以看出，它是一个线性模型，所以 "感知机的本质" 就是 "线性模型"。



//========================================================================================== 感知机功能演示
//========================================================================================== 感知机功能演示


//======================================== 逻辑和、逻辑与、AND（线性分类）：都为真才为真
//======================================== 逻辑和、逻辑与、AND（线性分类）：都为真才为真


（发烧）1（0.5）
			----->  Thea（0.7）  --------->1*0.5 + 1*0.5 > 0.7  ----> 1（感冒）
（咳嗽）1（0.5）


（发烧）1（0.5）
			----->  Thea（0.7）  --------->1*0.5 + 0*0.5 < 0.7  ----> 0（非感冒）
（咳嗽）0（0.5）


//======================================== 逻辑或、OR（线性分类）：一个为真就为真
//======================================== 逻辑或、OR（线性分类）：一个为真就为真


（生病）1（0.5）
			----->  Thea（0.2）  --------->1*0.5 + 1*0.5 > 0.2  ----> 1（上医院）
（体检）1（0.5）


（生病）1（0.5）
			----->  Thea（0.2）  --------->1*0.5 + 0*0.5 < 0.2  ----> 1（上医院）
（体检）0（0.5）



//============ 重点来了（重点）
//============ 重点来了（重点）

同样的结构实现了 "逻辑与"、同样的结构实现了 "逻辑或"，

同样的算法：不同点在于  Thea  的值，一个 0.7 、一个 0.2。

注意："自变量" 除了Thea、还有权重。

thea 和 权重设置多少能实现 "逻辑与"
thea 和 权重设置多少能实现 "逻辑或"

这些就是 "模型参数"

而 "权重" 和 "阈值" 设置多少时能达到业务需求，就是 "机器学习"，它要学习的内容。

求损失函数的极小值，
//=============（重点）===============================================
//=============（重点）===============================================
权重和偏置、权重和阈值、都是模型需要学习的。
需要通过梯度下降进行更新的


//========================================================  
//========================================================  

区别在于thea不同、权重等不同

	thea 和 权重设置多少能实现 "逻辑与"
	thea 和 权重设置多少能实现 "逻辑或"

	就是说 thea 和 权重设置多少 能满足当前的 "业务需求"

	这些就是 "模型参数"

	根据 "预测结果" 构建 "损失函数"。



//======================================================== 通过 "感知机" 来实现 "逻辑与、逻辑或"
//======================================================== 通过 "感知机" 来实现 "逻辑与、逻辑或"

def AND(x1,x2):
    '''
    逻辑与
    '''
    w1,w2 = 0.5,0.5
    theta = 0.7   #只有这个参数不同
    temp = w1* x1 + w2 * x2
    if temp <= theta:
        return 0
    else:
        return 1
print(AND(1,1)) #1
print(AND(1,0)) #0
print(AND(0,1)) #0
print(AND(0,0)) #0

def OR(x1,x2):
    '''
    逻辑或
    '''
    w1,w2 = 0.5,0.5
    theta = 0.3        #只有这个参数不同
    temp = w1* x1 + w2 * x2
    if temp <= theta:
        return 0
    else:
        return 1
print(OR(1,1)) #1
print(OR(1,0)) #1
print(OR(0,1)) #1
print(OR(0,0)) #0



//======================================================== 感知机的局限
//======================================================== 感知机的局限

感知机的局限在于无法处理 "异或" 问题（非线性问题）



0，0	返回0类别
1，1	返回0类别


0，1	返回1类别
1，0	返回1类别


线性不可分


//=============（重点）===============================================
//=============（重点）===============================================

在 "权重和阈值" 在 "设置不同值的时候"，就能达到 "逻辑与 " 和 "逻辑或"


"权重和阈值" 是 "模型" 需要 "自己学习的参数"



