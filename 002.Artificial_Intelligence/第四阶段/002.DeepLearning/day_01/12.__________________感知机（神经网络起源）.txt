//======================================================== 神经网络结构
//======================================================== 神经网络结构

（1）感知机
（2）神经网络
（3）激活函数

//======================================================== 感知机
//======================================================== 感知机

（1）  "感知机（Perceptron）" ，又称为 "人工神经元（Artificial neuron）"，
它是 "生物神经元" 在计算机中的 "模拟"。

（2）  	/** 生物神经元：

			树突（收集信息）
			细胞体（处理信息）
			轴突（传递信息）
			突触（输出信息）

			//===========================过程 
			从外界接收一定的信号：达到一定阈值，
			交给神经元处理，钾纳离子放电、激活。。
			生物学神经元的

		*/




	人工神经元，它也是从外界接收信号，
	"接收到信号" 之后，进行判断，是否达到阈值，

	1）达到阈值输出一个结果，
	2）没有达到阈值输出另一个结果。

	//========================== 举例说明：生物神经元
	//========================== 举例说明：生物神经元
	你现在出去游玩，突然飞来一只蝴蝶


	然后你会判断：
		蝴蝶：的出现是否达到伤害你的阈值，没有达到，你就不会逃跑
		蜜蜂：出现会达到伤害你的阈值，你就会逃跑

	对于 "人工感知机" 也是一样的。

	"外界输入的信号" 不一样，最终判断 "处理的结果" 也是不一样的。


（3）生物神经网络
    生物神经网络
	更多的 "生物神经元" 相连接，形成复杂的神经网络，
	人类的神经元数量是 10^11 数量级。

	//神经元越多，它的处理问题的能力越强
	海绵、蚂蚁、蜜蜂、青蛙、章鱼、人类，这些生物的神经元数量是不同的，
	//人类最多。  10^11 数量级



（4）感知机（Perceptron），
	 又称为神经元（Neuron，对生物神经元进行了模仿），
	 它是 "神经网络（深度学习）"的起源算法，

	它可以接收 "多个输入信号" ，产生 "一个输出信号"

		/** 感知机分类（只能做线性可分的任务）
			x1（0.2） --> w1									----------------- 0 分类
								-----> Thea -------->y-------->达到0.4
			x2（0.5） --> w2									----------------- 1 分类

			w1x1 + w2x2   与  Thea 比较

			（1） 蝴蝶来了0.2 不用跑
			（2） 蜜蜂来了0.5 要跳
			（3） 蝴蝶蜜蜂仪器来了， 0.7 要跳

		*/


		/** 
			感知机做回归：得到的是连续的值

			y = w1x1 + w2x2 - Thea  这样得到的就是连续的值。


		*/





//========================================================  "感知机" 的本质
//========================================================  "感知机" 的本质

 "感知机的本质" 就是 "线性模型"


//========================================================  
//========================================================  
"感知机"  能实现 "逻辑与" 、也能实现 "逻辑或" 
区别在于thea不同、权重等不同

	thea 和 权重设置多少能实现 "逻辑与"
	thea 和 权重设置多少能实现 "逻辑或"

	就是说 thea 和 权重设置多少 能满足当前的 "业务需求"

	这些就是 "模型参数"

	根据 "预测结果" 构建 "损失函数"。

	求损失函数的极小值，
	//=============（重点）===============================================
	//=============（重点）===============================================
	权重和偏置、权重和阈值、都是模型需要学习的。
	需要通过梯度下降进行更新的
	

	
	
//======================================================== 通过 "感知机" 来实现 "逻辑与、逻辑或"
//======================================================== 通过 "感知机" 来实现 "逻辑与、逻辑或"

def AND(x1,x2):
    '''
    逻辑与
    '''
    w1,w2 = 0.5,0.5
    theta = 0.7   #只有这个参数不同
    temp = w1* x1 + w2 * x2
    if temp <= theta:
        return 0
    else:
        return 1
print(AND(1,1)) #1
print(AND(1,0)) #0
print(AND(0,1)) #0
print(AND(0,0)) #0

def OR(x1,x2):
    '''
    逻辑或
    '''
    w1,w2 = 0.5,0.5
    theta = 0.3        #只有这个参数不同
    temp = w1* x1 + w2 * x2
    if temp <= theta:
        return 0
    else:
        return 1
print(OR(1,1)) #1
print(OR(1,0)) #1
print(OR(0,1)) #1
print(OR(0,0)) #0



//======================================================== 感知机的局限
//======================================================== 感知机的局限

感知机的局限在于无法处理 "异或" 问题（非线性问题）



0，0	返回0类别
1，1	返回0类别


0，1	返回1类别
1，0	返回1类别


线性不可分


//=============（重点）===============================================
//=============（重点）===============================================

在 "权重和阈值" 在 "设置不同值的时候"，就能达到 "逻辑与 " 和 "逻辑或"


"权重和阈值" 是 "模型" 需要 "自己学习的参数"



