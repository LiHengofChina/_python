
//===============================================================================
//===============================================================================

 "快速排序" 的 "独特之处" 在于，其速度取决于 "选择的基准值" ，



	选择排序，其运行时间为 O(n^2)，速度非常慢。

//=============================================================================== 合并排序（merge sort）	
//=============================================================================== 合并排序（merge sort）	

	还有一种名为 "合并排序（merge sort）" 的排序算法，
	其运行时间为 O(nlogn) ，比选择排序快得多！


	"快速排序" 的情况比较棘手，在最糟情况下，其运行时间为 O(n^2) 
	与 "选择排序" 一样慢，但这是 "最糟情况"

	在 "平均情况下" ，"快速排序" 的运行时间为 O(nlogn) 。

	//==================================
	//==================================
	若 "快速排序" 在 平均情况下的 "运行时间为 O(nlogn)  "
	而 "合并排序" 的运行时间总是 O(nlogn)
	为何不使用合并排序？它不是更快吗？

	//============================== 比较合并排序和快速排序? //意思是：同样是大O表示法，但它们表示的速度不一样
	//============================== 比较合并排序和快速排序? //意思是：同样是大O表示法，但它们表示的速度不一样
	//===
	假设有 "下面这样" 打印 列表中 "每个元素的简单函数"。

	def print_items(list):
	  for item in list:
		print item

	这个函数 遍历列表中的 "每个元素" 并将其打印出来。
	它迭代整个列表一次，因此运行时间为 O(n) 。
	//===
	现在假设你"对这个函数进行修改"，使其在打印 "每个元素前都休眠 1 秒钟"。
	from time import sleep
	def print_items2(list):
	  for item in list:
		sleep(1)
		print item
	它在打印每个元素前都暂停 1 秒钟。


	这两个函数都迭代整个列表一次，因此它们的运行时间都为 O(n)
	//指：print_items 和 print_items2

	//===这两个函数哪个更快呢？
	哪个函数的速度更快呢？
		print_items 要快得多，因为它没有在每次打印元素前都暂停1秒钟。
	//====结论：
		因此，虽然使用 "大 O 表示法" 表示时，
		这两个函数的速度相同，但实际上 print_items 的速度更快。
	//====
		在 "大 O 表示法 " O(n) 中，n 实际上指的是这样的。
				c * N
		c 是 "算法所需的固定时间量" ，被称为 常量。
	//====如上所示：		

	例如：
		print_items  所需的时间： 10 毫秒 * n
		print_items2 所需的时间：   1 秒 * n

	通常不考虑这个常量，

	因为 "如果两种算法" 的  "大 O 运行时间不同" 	
	 "这种常量" 将 "无关紧要"。 //所以省略

	//============================== //从另一个角度来说明常量是无关紧要的
	//============================== //从另一个角度来说明常量是无关紧要的

	拿 "二分查找" 和 "简单查找" 来举例说明。
	假设这两种算法的 "运行时间" 包含如下常量。

	简单查找：  10 毫秒 * N
	二分法查找：    1秒 * Log N

	你可能认为，简单查找的常量为 10 毫秒，而二分查找的常量为 1 秒，因此简单查找的速度要快得多。
	现在假设你要在包含 40 亿个元素的列表中查找，所需时间将如下。//把N换成具体的值

	简单查找：  10 毫秒 * 40亿 = 463天
	二分法查找：    1秒 * 32 = 32秒
	
	//======================
	正如你看到的，二分查找的速度还是快得多，常量根本没有什么影响。


	//==================================	但有时候，常量的影响可能很大，
	//==================================	但有时候，常量的影响可能很大，

	对快速查找和合并查找来说就是如此。

	快速查找的常量比合并查找小，
	因此如果它们的运行时间都为 O(nlogn)，
	快速查找的速度将更快。

	实际上，快速查找的速度确实更快，因为相对于遇上最糟情况，它遇上平均情况的可能性要大得多。


//=============================================================================== 总结
//=============================================================================== 总结
 
	（1）大 O 表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
 
	（2）比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时， 
		 O(logn) 的速度比 O(n) 快得多。
		 



