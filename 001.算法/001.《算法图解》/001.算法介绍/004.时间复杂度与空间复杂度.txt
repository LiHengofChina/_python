
//======================================================== 时间复杂度 / 空间复杂度 
//======================================================== 时间复杂度 / 空间复杂度

时间复杂度 / 空间复杂度，是写 "好程序" 的一个重要门槛。

//================= 时间复杂度（Time Complexity）
//================= 时间复杂度（Time Complexity）
回答的问题是：
	当输入规模 n 变大，程序执行 "步骤数" 如何增长？
			//操作步数越多，一般程序就会运行越久。

//================= 空间复杂度（Space Complexity）
//================= 空间复杂度（Space Complexity）
回答的问题是：
	当输入规模 n 变大， 需要多少 "额外内存"？
	是否开新数组、是否递归栈、是否辅助结构
			//额外内存用得越多，就越容易把内存用爆。


//======================================================== 大O表示方法
//======================================================== 大O表示方法
"时间复杂度" 和 "空间复杂度"，都使用大 O 表示法。Big-O 表示的是 "增长阶"

//======== 由坏到好
//======== 由坏到好

O(n²)      // "操作次数" 或 "额外内存" 与 n² 成正比
		   // 常见于双重循环
		   // n 稍微变大，消耗增长非常快

O(n log n) // 每个元素要处理一次（n）
		   // 同时每次处理又伴随对数级操作（log n）
		   // 常见于高效排序算法（如归并排序、快速排序的平均情况）
		   // 每个 n 的处理，都要付出一个 log n 的代价

O(n)       // "操作次数" 或 "额外内存" 与 n 成正比
		   // n增加， 操作次数 / 内存 也增加 n
		   // n 变大一倍，操作次数 / 内存也大致变一倍

O(log n)   // 每一步都把问题规模 "缩小一半"
		   // n 很大时，增长依然很慢
		   // 常见于二分查找、树结构查找
		   // 注意：增长的慢，但还是在增长

O(1)      // "操作次数" 或 "内存"  是常数，不随 n 变化 → O(1)



//======================================================== 示例：
//======================================================== 示例：
"时间复杂度" O(1)   
		   /**  例1： int x = arr[0];
				      不管数组有 10 个还是 1 亿个元素 	// arr[0] 👉 O(1)

				例2： int sum = a + b;
				      永远只做一次加法 	// a + b 👉 O(1)

				例3： if (x > 0) {
							y = 1;
					  }
					  最多判断一次		// x > 0 👉 O(1)
		   */
//======================================================== 示例：
//======================================================== 示例：
空间复杂度（Space Complexity） O(1) 
			/**
			* 例1：
			* int a = 1;
			* int b = 2;
			*
			* 只用了几个变量
			* 不管 n 多大，内存都不再增加
			* 👉 空间复杂度 O(1)
			*/
			/**
			 * 例2：
			 * int sum = 0;
			 * for (int i = 0; i < n; i++) {
			 *     sum += i;
			 * }
			 *
			 * 虽然循环跑了 n 次（时间 O(n)）
			 * 但额外只用了 sum、i 两个变量
			 * 👉 空间复杂度仍然是 O(1)
			 */
			 /**
			 * 例3：
			 * int max(int a, int b) {
			 *     return a > b ? a : b;
			 * }
			 *
			 * 没有新数组
			 * 没有递归
			 * 没有随 n 增长的数据结构
			 * 👉 空间复杂度 O(1)
			 */

//======================================================== 场景
//======================================================== 场景

优化程序：如果现在内存使用不再随 n 增长，那就是成功 "降低了空间复杂度"。
优化程序：如果随着 n 增加，执行步数不再增加，那就是成功降低了 "时间复杂度"。


//======================================================== 示例：
//======================================================== 示例：

String tableName = extractTableNameFromFile(file);//，“文件名不要后缀” 即 “表名”
List<MaskRuleVo> maskRuleVoList = new ArrayList<>();
for (MaskRuleVo maskRulevo : maskRuleVos) {
	if (tableName.equals(maskRulevo.getTableName())) {
		maskRuleVoList.add(maskRulevo);
	}
}


n：maskRuleVos.size()（输入规模）
k：满足条件的元素个数（命中次数）

所以：
	时间复杂度是 O(n)
	空间复杂度是 O(k) ，O(n) 表示全部命中


不管 n 多大，只要命中规则很少，新分配的 List 就很小

//如果 maskRulevo 本身 查询SQL中就直接按条件查询，这里就不用过滤了， 
//如果 maskRulevo 本身 查询SQL中就直接按条件查询，这里就不用过滤了， 

那么

如果这里走了全表扫描，而原来的查询没走，那么你只是把 “时间复杂度转移到到了mapper层”，空间复杂度 降低到了O(1)
如果这里走了全表扫描，而原来的查询也走了，那么你只是 “java层时间复杂度由 O(k) 降为 O(1)，但整体不是O(n)， 空间复杂度 降低到了O(1)


//======================================================== 适用范围
//======================================================== 适用范围

时间复杂度、空间复杂度是通用的计算模型，
不只适用于 Java，同样适用于：

前端（JS / 渲染 / 算法 / DOM 操作）
数据库（查询、索引、执行计划）
操作系统（调度、内存管理、IO）
任何程序或系统

只是分析边界不同（前端 / 后端 / DB / OS），但思想完全通用。



