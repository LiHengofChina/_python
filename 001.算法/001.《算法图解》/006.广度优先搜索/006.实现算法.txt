


//============================================= 实现算法
//============================================= 实现算法

	（1）创建一个队列，用于存储要检查的人

	（2）从队列中弹出一个人

	（3）检查这个人是不是芒果销售商

	（4）如果是：结束
		 如果不是：把朋友的朋友加入到 //注意：这里是单向的

	（5）回到第（2）步

	（6）如果队列为空，就说明 "你的人际关系网中" 没有芒果销售商




//============================================= Python代码 
//============================================= Python代码 

	while search_queue:  ←------只要队列不为空
		person = search_queue.popleft()  ←------就取出其中的第一个人
		if person_is_seller(person):  ←------检查这个人是否是芒果销售商
			print person + " is a mango seller!"  ←------是芒果销售商
			return True
		else:
			search_queue += graph[person]  ←------不是芒果销售商。将这个人的朋友都加入搜索队列
	return False  ←------如果到达了这里，就说明队列中没人是芒果销售商


	/**
		这个算法将不断执行，直到满足以下条件之一：
			（1）找到一位芒果销售商；
			（2）队列变成空的，这意味着你的人际关系网中没有芒果销售商。
	*/

//============================================= 特殊情况
//============================================= 特殊情况
	
		//==================（1）
		//==================（1）
		Peggy 既是 Alice 的朋友又是 Bob 的朋友，
		因此她将被加入队列两次：
		另一次是在添加 Bob 的朋友时。
		因此，搜索队列将包含两个 Peggy。

		但你只需检查 Peggy 一次，看她是不是芒果销售商。如果你检查两次，就做了无用功。
		因此，检查完一个人后，应将其标记为已检查，且不再检查他。

		//==================（2）
		//==================（2）
		假设你的人际关系网类似于下面这样。 相互都是邻居
		就可能会导致无限循环
		
		
//============================================= 检查过的人，就不再检查，优化代码
//============================================= 检查过的人，就不再检查，优化代码



		def search(name):
			search_queue = deque()
			search_queue += graph[name]
			searched = []  ←------------------------------这个数组用于记录检查过的人
			while search_queue:
				person = search_queue.popleft()
				if person not in searched:     ←----------仅当这个人没检查过时才检查
					if person_is_seller(person):
						print person + " is a mango seller!"
						return True
					else:
						search_queue += graph[person]
						searched.append(person)    ←------将这个人标记为检查过
			return False


		search("you")




//============================================= 运行时间
//============================================= 运行时间

	如果你在 "你的整个人际关系网" 中 搜索芒果销售商，
	就意味着你将沿每条边前行
	因此运行时间至少为 O(边数)。
	
	你还使用了一个队列，其中包含要检查的每个人。
	将一个人添加到队列需要的时间是固定的，
	因此对每个人都这样做需要的总时间为 OO (人数)。


	所以，广度优先搜索的运行时间为 O(人数 + 边数)O(人数+边数)，
	这通常写作 O(V+E)O(V+E)，
	其中 VV 为顶点（vertice）数，
	EE 为边数。

//============================================= 注意：
//============================================= 注意：

	图中的箭头画法：
	依赖谁就指向谁:

//============================================= 拓扑
//============================================= 拓扑

	如果任务 A 依赖于任务 B，在列表中任务 A 就必须在任务 B 后面。
	这被称为拓扑排序，使用它可根据图创建一个有序列表。

	假设你正在规划一场婚礼，并有一个很大的图，
	其中充斥着需要做的事情，但却不知道要从哪里开始。
	这时就可使用拓扑排序来创建一个有序的任务列表。


//============================================= 特殊的图：树
//============================================= 特殊的图：树

	假设你有一个家谱。
	
	这是一个图，因为它由节点（人）和边组成。
	其中的边从一个节点指向其父母，
	但所有的边都往下指。
			//父母在下面，说明父母是基础
	
	这种图被称为树。树是一种特殊的图，其中没有往后指的边。

	
	树是图的子集，因此树都是图，
	
	但图可能是树，也可能不是。
	
	
//=============================================总结：
//=============================================总结：

	使用图来建立模型，再使用广度优先搜索来解决问题。
	
