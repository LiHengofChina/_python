
如何用代码实现图：

//=============================================
//=============================================

		（1）图由多个节点组成。
		（2）每个节点都与邻近节点相连
			
			/**
				如果表示类似于“你→Bob”这样的关系呢？
				好在你知道的一种结构让你能够表示这种关系，
				它就是 散列表！
				
				散列表能够 "将"
			*/
			
		//===================== 比如：简单的关系，你和你的朋友
		//===================== 比如：简单的关系，你和你的朋友
		graph = {}
		graph["you"] = ["alice", "bob", "claire"]

		//===================== 复杂一点的关系
		//===================== 复杂一点的关系
		graph = {}
		graph["you"] = ["alice", "bob", "claire"]
		graph["bob"] = ["anuj", "peggy"]
		graph["alice"] = ["peggy"]
		graph["claire"] = ["thom", "jonny"]
		graph["anuj"] = []
		graph["peggy"] = []
		graph["thom"] = []
		graph["jonny"] = []


//=============================================	"键—值"对添加顺序
//=============================================	"键—值"对添加顺序

		顺便问一句：键—值对的添加顺序重要吗？

		如果你这样编写代码：
		graph["claire"] = ["thom", "jonny"]
		graph["anuj"] = []

		而不是这样编写代码：
		graph["anuj"] = []
		graph["claire"] = ["thom", "jonny"]

		对结果有影响吗？
		只要回顾一下前一章介绍的内容，你就知道没影响。
		散列表是无序的，因此添加 "键—值对" 的顺序无关紧要。

//=============================================
//=============================================

		//======
		//======
		Anuj、Peggy、Thom 和 Jonny 都没有邻居，
		这是因为虽然有指向他们的箭头，
		但没有从他们出发指向其他人的箭头。

		//====== 有向图
		//====== 有向图
		这被称为 有向图（directed graph），其中的关系是单向的。	
		graph["bob"] = ["anuj", "peggy"]
		graph["anuj"] = []
		因此，Anuj是Bob的邻居，但Bob不是Anuj的邻居。

		//====== 无向图
		//====== 无向图
		
		无向图（undirected graph）没有箭头，
		直接相连的节点互为邻居。
				/**
					例如，下面两个图是等价的。
						（1）双向箭头
						（2）无箭头
				*/




