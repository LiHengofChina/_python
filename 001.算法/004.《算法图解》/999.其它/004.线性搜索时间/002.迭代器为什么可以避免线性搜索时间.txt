

//=============================================================
//为什么 "迭代器" 能避免 "线性搜索时间" 呢
//=============================================================

在一些数据结构中，通过索引访问元素可能需要线性时间（即 O(n) 时间复杂度
这是因为需要逐个 "检查元素" 直到找到 "目标元素"


"迭代器" 可以 "避免这种情况" ，
因为迭代器通常 "直接访问数据结构" 中的 "下一个元素"，不需要进行 "索引查找"。

//========== 详细解释
//========== 详细解释
（1）线性搜索时间（Linear Search Time）：
	（1）通过索引访问数组中的元素，
			如果 "数组的底层实现" 是 "链表或者其他非连续存储结构"，
			那么需要 "逐个遍历元素" 来找到 "目标元素"。
	（2）时间复杂度为 O(n)，因为最坏情况下可能需要遍历整个数组。

（2）常数时间（Constant Time）：
		在一些情况下，访问 "特定位置的元素（如第一个或最后一个元素）" 可以在常数时间内完成。	
		如果数组是基于连续存储结构（如数组或向量），这种访问可以在 O(1) 时间内完成。

（3）迭代器可以直接 "指向下一个元素" ，无需进行 "索引计算或搜索" 。
	 在遍历整个数组时，使用 "迭代器" 通常更高效，尤其是在底层实现不是连续存储的情况下。


//=============================================================
// 意思是说 "通过索引访问元素" 时，先要 "计算下一个索引，
// 并找到索引指向数据的位置" ，这个过程是花费时间的，
// 而迭代器里面有下一个元素的位置，它不需要计算，
//=============================================================

通过索引访问元素时，需要先计算下一个索引，
并找到索引指向的数据的位置，而这个过程是花费时间的。
相比之下，迭代器直接保存了下一个元素的位置，
因此不需要进行额外的计算或查找，从而更高效。

//===更详细的解释
//===更详细的解释
（1）通过索引访问元素
	计算索引：当访问数组中的某个元素时，首先需要计算出该元素的索引位置。
	查找元素：然后需要找到该索引对应的内存位置，并读取元素的数据。
	复杂度：对于连续存储的数组（如C语言中的数组），通过索引访问是 O(1) 时间复杂度。
			然而，对于非连续存储的数据结构（如链表），查找元素可能需要遍历整个结构，
			从而导致 O(n) 的时间复杂度。

（2）使用迭代器访问元素
	直接访问：迭代器通常包含指向当前元素和下一个元素的指针，因此可以直接访问下一个元素。
	避免计算：由于迭代器已经保存了下一个元素的位置，不需要再计算或查找索引位置。
	复杂度：迭代器的访问操作通常是 O(1)时间复杂度，因为它不需要进行额外的计算或查找。


//=============================================================
//如果通过 迭代器 查找元素，它还不是一样需要遍历元素，直到找到吗？
//=============================================================


（1）通过迭代器查找特定元素仍然需要遍历元素，直到找到目标元素。
	 因此，对于查找特定元素，迭代器的效率与索引遍历的效率基本相同，都是线性时间复杂度O(n)。

（2）然而，当你需要逐个访问数组中的所有元素时，迭代器通常更高效，特别是在复杂的数据结构中。
	 迭代器的优势主要体现在以下几个方面：

