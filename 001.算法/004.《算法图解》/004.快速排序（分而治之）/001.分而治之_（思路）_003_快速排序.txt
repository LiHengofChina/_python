
	//======================================= "快速排序"
	//======================================= "快速排序"
		"快速排序" 是一种 "常用的排序算法" ，
		比 "选择排序" 快得多。

		//================== 例如：

		C语言标准库中函数 qsort 实现的就是快速排序，快速排序也使用了 D&C



	//======================================= 使用快速排序对数据进行排序
		（1）长度为 0 ，长度为 1 
				//最简单的数据
				//============================所以：
				//基线条件是 ===> 数组为空，或者只有一个元素
				if( arr.length < 2) {
					return arr
				}

		（2）对 "包含两个元素的数组" 进行排序
			 检查第一个元素是不是比第一个元素小，如果是，则交换他们位置

		（3）对 "包含三个元素的数组" 进行排序
			 由于要使用 D&C 因此需要 "将数组分解"，
			 直到满足 "基线条件"

			 ......

	//=======================================  "快速排序" 的工作原理
	//=======================================  "快速排序" 的工作原理


				[33,15,10]

		（1） 首先从数组中 "选择一个元素"，这个元素被称为 "基准值(pivot)"
			  暂时将将 "数组的第一个元素" 用作基准值。
				[33]

		（2） 接下来、找出 "比基准值小的元素" 和 "比基准值大的元素"//比基准值大的是空
				[15,10]  [33]  []
			 //============== 分区操作
			  这被称为 "分区（partitioning）" 。现在你有3部分

			  1 . 小于基准值的数组成的 "子数组"
			  2 . 基准值
			  3 . 大于基准值的数组成的 "子数组"

			  //这里只是进行了分区，两个 "子数组" 是无序的
			  //但如果这两个数组是有序的，对整个数组进行排序将非常容易。
			  
			  //============
			  如果 "子数组" 是有序的，
			  就可以像下面这样合 并得到一个有序的数组：
			  左边的数组 + 基准值 + 右边的数组。
			  
			  在这里，就是 [10, 15] + [33] + []，
			  结果为有序数组 [10, 15, 33]。
			  
			  //============
			  如何对子数组进行排序呢？
			  
			  对于包含 "两个元素的数组（左边的子数组）" 以及 "空数组（右边的子数组）"
			  
			  只要 "对这两个子数组" 进行 "快速排序"，再合并结果，就能 "得到一个有序数组" ！
							  
				quicksort([15, 10]) + [33] + quicksort([])
				> [10, 15, 33]  ←------一个有序数组
							  
							  
	//=======================================
	//=======================================
	将任何元素用作基准值都可行
	......
	因此你能够对包含五个元素的数组进行排序。
	同理，你能够对包含六个元素的数组进行排序，以此类推。
	
//============================================================================= 归纳证明
//============================================================================= 归纳证明
	
	"归纳证明" 是一种 "证明算法行之有效" 的方式
	它分两步："基线条件" 和 "归纳条件"。
	
	是不是有点似曾相识的感觉？
	
	//====================== 例如：
	假设我要证明我能爬到梯子的最上面。
	归纳条件是这样的：
		如果我站在一个横档上，就能将脚放到上面一个横档上。
		换言之，如果我站在第二个横档上，就能爬到第三个横档。
	这就是归纳条件。
		而基线条件是这样的，即我已经站在第一个横档上。
		因此，通过每次爬一个横档，我就能爬到梯子最顶端。
//====================================== 对于 "快速排序" 进行 "归纳证明" 
//====================================== 对于 "快速排序" 进行 "归纳证明" 
	对于快速排序，可使用类似的推理。
	
	在 "基线条件" 中，我证明 "这种算法" 对 "空数组或包含一个元素" 的数组管用。
	在归纳条件中，
	我证明如果快速排序对包含一个元素的数组管用，
	对包含两个元素的数组也将管用；
	如果它对包含两个元素的数组管用，对包含三个元素的数组也将管用，
	以此类推。因此，我可以说，快速排序对任何长度的数组都管用。
	"归纳证明"，与 D&C 协同发挥作用。
 
	
//====================================== 快速排序总结
//====================================== 快速排序总结
	
	（1）.分成两种情况
			元素只有 0 个或 1 个  的数组，
			//代码  arr.length < 2
			
	（2）. 选择一个基准值，将数据内容循环分成 2 类

			一 类小于基准值 //A
			再加上基准值    //B
			一 类大于基准值 //C
			//==============这3部分作为一个子数组，进行排序
			[A] + [B] + [C]
			
			这样就得到了有序的顺序
			
			而 [A] 和 [C] 中的内容，并不是有序的，
			
			所以A和 C需要同时进行递归

			即：  return quicksort(less) + [pivot] + quicksort(greater)
			
			//******************
			//注意，这里有一点是，两边同时排序。



