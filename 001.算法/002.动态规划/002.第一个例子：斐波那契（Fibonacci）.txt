
//====================== 含义
//====================== 含义

"斐波那契（Fibonacci）" 它是一个经典数列：

从第 3 项开始，每一项都等于前两项之和：
	0 1 1 2 3 5 8 13 21 34 55 89 .....

//====================== 场景
//====================== 场景

在自然界里很常见，比如：兔子繁殖模型、向日葵种子螺旋、松果鳞片排列等。

//==========================================================================================  解法一：纯递归（指数级，别在生产里用） //复杂度：O(φ^n)，非常慢。
//==========================================================================================  解法一：纯递归（指数级，别在生产里用） //复杂度：O(φ^n)，非常慢。


def fib(n: int) -> int:
    if n<=1:
        return n
    return fib(n-1) + fib(n-2)

def main():
    n = 100
    print(f"fib(n) = {fib(n)}")
if __name__ == '__main__':
    main()

//==========================================================================================  解法二：记忆化（自顶向下，Top-Down）
//==========================================================================================  解法二：记忆化（自顶向下，Top-Down）

from functools import lru_cache

# 使用 lru_cache 装饰器自动实现记忆化
@lru_cache(maxsize=None)
def fib_memo(n: int) -> int:
    """用记忆化递归计算斐波那契数"""
    if n <= 1:
        return n
    return fib_memo(n - 1) + fib_memo(n - 2)
//记忆化递归（加结果缓存）就是 动态规划的 Top-Down 写法

/**
为什么加了缓存，就快了那么多？
	比如你算 fib(5)：
	fib(5)
	 ├─ fib(4)
	 │   ├─ fib(3)
	 │   │   ├─ fib(2)
	 │   │   │   ├─ fib(1) → 1
	 │   │   │   └─ fib(0) → 0
	 │   │   └─ fib(1) → 1
	 │   └─ fib(2)  ← 重复算！
	 │       ├─ fib(1) → 1
	 │       └─ fib(0) → 0
	 └─ fib(3)  ← 重复算！
		 ├─ fib(2)  ← 又重复算！
		 └─ fib(1) → 1

你看到 fib(2)、fib(3) 被算了好多次。
第一次算 fib(2) → 存到缓存。
下次再遇到 fib(2) → 直接取缓存，不再递归。

*/

//==========================================================================================  解法三：表格法（自底向上，Bottom-Up，还能滚动数组降空间：指用少量变量存放，不用数组）
//==========================================================================================  解法三：表格法（自底向上，Bottom-Up，还能滚动数组降空间：指用少量变量存放，不用数组）

def fib_bu(n: int) -> int:
    """自底向上（Bottom-Up）动态规划求斐波那契"""
    if n <= 1:
        return n
    a, b = 0, 1  # dp[0], dp[1]
    for _ in range(2, n + 1):
        c = a + b  # dp[i] = dp[i-1] + dp[i-2]
        a, b = b, c
    return b

这一版和记忆化递归本质一样，复杂度都是 O(n)，
但不用递归，也不会遇到递归深度限制，速度和内存都更稳。
	/**
		自底向上就是所有结果存放到一个表格中：
		先求小的那个dp[0]，然后dp[1]，用dp[i]表示 ，
		后面就是dp[i-2] + dp[i-1]，这样就很方便的后面的值

		往后滑动一格，保持住最新的两个斐波那契数。

	*/

def fib_dp(n: int) -> int:
    if n <= 1:
        return n
    dp = [0] * (n + 1)  # 创建长度 n+1 的数组
    dp[0], dp[1] = 0, 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

/**
自底向上 (Bottom-Up)：先写出最小的两个数，然后一步一步往上推，就像人拿纸笔算 Fibonacci 一样。

递归 (Top-Down)：更像是“先问结果，再去追溯需要的子问题”，不太符合人类自然的计算习惯。
*/


/**
完整表格法：真的用数组存所有 dp[i]。
		//完整表格法（真的开数组 dp[]）
		//空间复杂度：O(n)
		//好处：直观，能看到整个表格
		//坏处：要开数组，浪费空间

优化版表格法：发现只用到前两个值，就只保留两个变量。

		//空间复杂度：O(1)
		//好处：只存两个变量，节省内存
		//坏处：中间结果看不到

*/

/**
	像 Fibonacci 这种只依赖前两个状态，就可以优化成两个变量（滚动数组）。
	但在 字符串对比类算法（比如最长公共子序列 LCS、编辑距离 Edit Distance、diff 算法）里：
*/

//========================================================================================== 解法四：快速倍增法 (Fast Doubling Method) 和 矩阵快速幂本
//========================================================================================== 解法四：快速倍增法 (Fast Doubling Method) 和 矩阵快速幂本

快速倍增法 (Fast Doubling Method)，其实和 矩阵快速幂本质一样。

思路：利用 Fibonacci 的数学公式，把 F(n) 拆成 F(n/2) 的函数值，递归分治。

时间复杂度：O(log n)

特点：适合算特别大的 n，比如 fib(1000000)。

快速倍增法和矩阵快速幂，本质上不是 DP 填表，而是利用 Fibonacci 的数学公式做优化。
它们和自底向上 DP 目标一样（求 fib(n)），只是换了一套更快的数学推导方法。

但这种适合求值运算如相似度计算，
不适合对比差异，因为要知道每一个结果。


快速倍增 / 矩阵快速幂只适合算单个 fib(n) 这样的数值。
而像字符串对比、差异比较，
要知道每个子状态结果，就必须保留完整 DP 表，不能只算最终值。
