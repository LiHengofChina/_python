
问题：一次走 1 或 2 阶，爬到第 n 阶有几种走法？
状态：dp[i] 表示到达第 i 阶的方案数。
转移：dp[i] = dp[i-1] + dp[i-2]（最后一步来自 i-1 或 i-2）。
			//"最后一步" 是你只能 “上一步台阶”或"两步台阶"
边界：dp[0]=1（站在地面一种状态），dp[1]=1。
答案：dp[n]。

def climb_stairs(n: int) -> int:
    """动态规划解法：爬楼梯问题"""
    if n <= 1:
        return 1

    a, b = 1, 1  # dp[0], dp[1]
    for _ in range(2, n + 1):
        c = a + b  # dp[i] = dp[i-1] + dp[i-2]
        a, b = b, c
    return b


def main():
    # 小测试
    print(climb_stairs(2))  # 2: (1+1), (2)
    print(climb_stairs(3))  # 3: (1+1+1), (1+2), (2+1)
    print(climb_stairs(5))  # 8


if __name__ == "__main__":
    main()

print(climb_stairs(3))  # 3: (1+1+1), (1+2), (2+1) 表示 有3种走法，到
达第3台阶，要么1 + 1 +1，要么 2 + 1 要么1+ 2，这这种走法的值都3，其实这是利用台阶数量3，就是有几中加法得到3 ，但加数只能是1 或 2


/**
	爬楼梯问题的本质

	到第 n 阶，就是把整数 n 拆分成若干个 1 和 2 的有序和。
	"有序" 很重要：1+2 和 2+1 被认为是两种不同的走法。

	所以 climb_stairs(n) 的值 = 由 1 和 2 构成的、和为 n 的有序拆分数。
*/

/**
再看 n = 4

所有的有序拆分：

1 + 1 + 1 + 1

1 + 1 + 2

1 + 2 + 1

2 + 1 + 1

2 + 2

共 5 种，所以 climb_stairs(4) = 5。
*/

//====================================================================
//====================================================================
第三步：为什么能覆盖所有走法？

因为公式 dp[i] = dp[i-1] + dp[i-2] 本质上就是在 枚举最后一步：

	最后一步跨 1 阶 → 来自 dp[i-1]

	最后一步跨 2 阶 → 来自 dp[i-2]

这样一步步推进，就把所有可能的走法都累计起来了。


/**
每一步都有可能成为“最后一步”。

	到达第 i 阶时，最后一步可能是从 i-1 跨 1 阶，或者从 i-2 跨 2 阶。

当它成为最后一步时，走法数 = 前面走法数之和。

	从 i-1 跨过来，走法数就是 dp[i-1]。

	从 i-2 跨过来，走法数就是 dp[i-2]。

	所以总数 = dp[i-1] + dp[i-2]。

这就是公式 dp[i] = dp[i-1] + dp[i-2] 的本质。

*/

