
//======================================================== 填装因子
//======================================================== 填装因子

//=============== "散列表" 的 "填装因子"
//=============== "散列表" 的 "填装因子"

	
	
	"散列表" 使用数组来存储数据，
	因此你需要计算 "数组中" 被占用的 "位置数"。

	//===================== 示例1：
	//===================== 示例1：
	长度为5的数组，占用了2个，
	因此填装因子为 2/5，即 0.4。

	//===================== 示例2：
	//===================== 示例2：
	长度为3的数组，占用了1个
	因此填装因子为 1/3
	
	//===================== 示例3：
	//===================== 示例3：
	假设你要在散列表中存储 100 种商品的价格，
	而该散列表包含 100 个位置。
	
	（1）那么在最佳情况下，每个商品都将有自己的位置。
		这个散列表的填装因子为 1 。
	（2）如果这个散列表只有 50 个位置呢？
		 填充因子将为2。
		 //    100/50  100个元素占用50个位置
		 不可能让每种商品都有自己的位置，因为没有足够的位置！
//=============== 调整长度
//=============== 调整长度
	填装因子大于 1 意味着商品数量超过了 "数组的位置数" 。
	一旦填装因子开始增大，
	你就需要在散列表中添加位置，
	这被称为 调整长度（resizing）。
	/**

		如：当前散列表的填装因子是 3/4
			你需要调整长度
			（1）你首先创建一个更长的新数组。//通常将数组增长一倍。
			（2）接下来，
				 你需要使用函数 hash 将所有的元素都插入到这个新的散列表中。
			这个新散列表的填装因子为 3/8，比原来低多了！
	*/

	总结：
		填装因子越低，发生冲突的可能性越小，散列表的性能越高。
		//一个不错的经验规则是：一旦填装因子大于 0.7，就调整散列表的长度。

	/**
		你可能在想，调整散列表长度的工作需要很长时间！
		你说得没错，调整长度的开销很大，因此你不会希望频繁地这样做。
		但平均而言，即便考虑到调整长度所需的时间，
		散列表操作所需的时间也为 O(1)O(1) 。
	*/
	
	



