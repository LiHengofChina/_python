
//=====================================================
//=====================================================

	运行时间为 O(n!) 的算法

	"这个算法" 要解决的是 "计算机科学领域" 非常著名的 "旅行商问题"


	其计算时间增加得非常快，
	而有些非常聪明的人都认为没有改进空间。

	//==================================
	//==================================
	有一位旅行商。
	他需要前往 5 个城市。


	这位旅行商（姑且称之为 Opus 吧）要前往这 5 个城市，
	同时要确保旅程最短。
	为此，可考虑前往这些城市的各种可能顺序。

	对于每种顺序，他都计算总旅程，再挑选出旅程最短的路线。

	（1）	5 个城市有 120 种不同的排列方式。
			因此，在涉及 5 个城市时，解决这个问题需要执行 120 次操作。
	（2）	涉及 6 个城市时，需要执行 720 次操作（有 720 种不同的排列方式）。
			涉及 7 个城市时，需要执行 5040 次操作！


	推而广之，涉及 n 个城市时，需要执行 n!（n 的阶乘）次操作才能计算出结果。


	因此运行时间为 O(n!) ，即阶乘时间
	除非涉及的城市数很少，否则需要执行非常多的操作。
	如果涉及的城市数超过100，
	根本就不能在合理的时间内计算出结果——等你计算出结果，太阳都没（下山）了。


	//==================================
	//==================================
	这种算法很糟糕！Opus 应使用别的算法，
	可他别无选择。这是计算机科学领域待解的问题之一。
	对于这个问题，"目前还没有找到更快的算法" *************************


