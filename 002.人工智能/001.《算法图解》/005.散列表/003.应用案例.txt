

"散列表" 被用于 "大海捞针式" 的查找。


//=============================================================================== 将散列表用于查找
//=============================================================================== 将散列表用于查找


（1） "电话号码"
	  手机都内置了 "方便的电话簿" ，其中 "每个姓名" 都有对应的 "电话号码" 。
	  这非常适合使用散列表来实现！
	  //

（2）  DNS 解析
	   你在 "访问像 http://adit.io 这样的网站时"，
	   计算机必须将 adit.io 转换为 IP 地址。

	   adit.io ====> 173.255.248.55

	   无论你访问哪个网站，其网址都必须转换成 IP 地址。

	   Google.com   ====> 74.125.239.133
	   FACEBOOK.com ====> 173.252.120.6
	   Scribd.Com   ====> 23.235.47.175

	   这就非常适合使用散列表，
	   这个过程被称为：DNS解析(DNS resolution)，

	   "这个过程被称为 DNS解析（DNS resolution）"
	   "散列表是提供这种功能的方式之一"	

（3）  投票站
	   假设你负责管理一个投票站。
	   显然，每人只能投一票，但如何避免重复投票呢？有人来投票时，
	   你询问他的全名，并将其与已投票者名单进行比对。
	   如果名字在名单中，就说明这个人投过票了，

	   因此将他 "拒之门外" ！否则，就将他的姓名 "加入到名单" 中，并让他投票。
	   现在假设有很多人来投过了票，因此名单非常长。

	   使用散列表！

	   有一种更好的办法，为此，首先创建一个散列表，用于记录已投票的人。
	   >>> voted = {}

	   有人来投票时，检查他是否在散列表中。
	   >>> value = voted.get("tom")

	   如果 "tom" 在散列表中，函数 get 将返回 true；否则返回 None。
	   
（4）  将散列表用作缓存
	   如果你在网站工作，可能听说过 "进行缓存" 是一种不错的做法。
	   
	   下面简要地：介绍其中的原理。
	   
	   假设 "你访问网站 facebook.com" 。
	   
	   (1) 你向 Facebook 的服务器发出请求。

	   (2) 服务器做些处理，"生成一个网页" 并将其发送给你。
				/**
						Facebook 的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒钟的时间。
						作为用户的你，可能感觉这几秒钟很久，进而可能认为 Facebook 怎么这么慢！另一方面，
						Facebook 的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。
						为服务好所有用户，Facebook 的服务器实际上在很努力地工作。有没有办法让 Facebook 的服务器少做些工作，
						从而提高 Facebook 网站的访问速度呢？


						Facebook 的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒钟的时间。
						作为用户的你，可能感觉这几秒钟很久，进而可能认为 Facebook 怎么这么慢！
						另一方面，Facebook 的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。
						为服务好所有用户，Facebook 的服务器实际上在很努力地工作。有没有办法让 Facebook 的服务器少做些工作，
						从而提高 Facebook 网站的访问速度呢？
				*/

	   (3) 你获得一个网页。

			假设你有个侄女，总是没完没了地问你有关星球的问题。
			火星离地球多远？月球呢？木星呢？每次你都得在 Google 搜索，
			再告诉她答案。
			这需要几分钟。现在假设她老问你月球离地球多远，
			很快你就记住了月球离地球 238 900 英里。
			因此不必再去 Google 搜索，你就可以直接告诉她答案。
			这就是缓存的工作原理：网站将数据记住，而不再重新计算。

			如果你登录了 Facebook，
			你看到的所有内容都是为你定制的。
			你每次访问 facebook.com，
			其服务器都需考虑你感兴趣的是什么内容。
			但如果你没有登录，
			看到的将是登录页面。每个人看到的登录页面都相同。
			Facebook 被反复要求做同样的事情：
			"当我注销时，请向我显示主页。" 有鉴于此，
			它不让服务器去生成主页，
			而是将主页存储起来，并在需要时将其直接发送给用户。

//=============================================================================== 缓存
//=============================================================================== 缓存

			用户能够更快地看到网页，
			就像你记住了月球与地球之间的距离时一样。
			次你侄女再问你时，
			你就不用再使用 Google 搜索，
			立刻就可以告诉她答案。

			Facebook 需要做的工作更少。


			缓存是一种常用的加速方式，
			所有大型网站都使用缓存，
			而 "缓存的数据" 则存储在 "散列表" 中！


			Facebook不仅缓存主页，
			还缓存 About 页面、Contact 页面、
			Terms and Conditions 页面等众多其他的页面。
			因此，它需要将页面 URL 映射到页面数据。

			当你访问 Facebook 的页面时，它 "首先检查散列表中" 是否存储了该页面。


			仅当URL不在缓存中时，你才让服务器做些处理，
			并将处理生成的数据存储到缓存中，再返回它。
			这样，当下次有人请求该 URL 时，你就可以直接发送缓存中的数据，
			而不用再让服务器进行处理了。

//=============================================================================== 这里总结一下，散列表适合用于：
//=============================================================================== 这里总结一下，散列表适合用于：


（1）模拟映射关系；
（2）防止重复；
（3）缓存/记住数据，以免服务器再通过处理来生成它们。

